内聚（在计算机科学中）被定义为“模块内的元素属于一起的程度。”1
模块化和内聚：设计基础
我最喜欢用 Kent Beck 的话来描述优秀的软件设计：
把不相关的东西拉得更远，把相关的东西放在一起。

这个简单、略带玩笑的短语有一些真实的道理。好的软件设计实际上是关于我们在我们创建的系统中组织代码的方式。我所有推荐的帮助我们管理复杂性的原则实际上都是关于划分我们的系统。我们需要能够用更小、更容易理解、更容易测试的离散部分来构建我们的系统。为了实现这一点，我们当然需要能够让我们“将不相关的东西拉得更远”的技术，但我们也需要认真对待“将相关的东西放在一起”的需要。这就是内聚的用武之地。
内聚是这里比较棘手的概念之一。我可以做一些天真的事情，比如在我的编程语言中支持模块的想法，并因此声称我的代码是模块化的。这是错误的；简单地将一组不相关的东西扔到一个文件中并不会使代码模块化，但在最微不足道的意义上。

1. 来源：维基百科 https://en.wikipedia.org/wiki/Cohesion_(computer_science)

当我谈到模块化时，我真正指的是系统中真正隐藏其他组件（模块）信息的组件。如果模块内的代码没有内聚力，那么这不起作用。
问题在于，这很容易出现过于简单化的解释。这可能是从业者的艺术、技能和经验真正发挥作用的地方。真正的模块化系统和内聚力之间的这种平衡点似乎常常让人们感到困惑。

## 内聚的基本降低

您是否经常看到一段代码会检索一些数据，解析它，然后将其存储在其他地方？ “存储”步骤肯定与“更改”步骤有关吗？这不是很好的内聚吗？它们是我们共同需要的所有步骤，不是吗？
好吧，不是真的——让我们看一个例子。首先我的警告：这里很难区分几个想法。这段代码不可避免地会展示本节中的每个想法，所以我依靠你来关注它涉及内聚的地方，当我还涉及关注点分离、模块化等时，我会故意微笑。
清单 10.1 显示了相当令人不快的代码作为演示。然而，我的目的是为我们提供一些具体的探索。这段代码读取一个包含单词列表的小文件，按字母顺序对它们进行排序，然后用生成的排序列表写入一个新文件——加载、处理和存储！
对于许多不同的问题，这是一个相当常见的模式：读取一些数据，处理它，然后将结果存储在其他地方。
清单 10.1 非常糟糕的代码，天真的内聚

```java
public class ReallyBadCohesion
{
    public boolean loadProcessAndStore() throws IOException
    {
        String[] words;
        List<String> sorted;

        try (FileReader reader = 
                    new FileReader("./resources/words.txt"))
        {
            char[] chars = new char[1024];
            reader.read(chars);
            words = new String(chars).split(" |\0");

        }
        sorted = Arrays.asList(words);
        sorted.sort(null);
 
        try (FileWriter writer = 
                    new FileWriter("./resources/test/sorted.txt"))
        {
            for (String word : sorted)
            {
                writer.write(word);
                writer.write("\n");
            }
            return true;
        }
    }
}
```

代码清单 10.2 仍然不好，但它更有内聚力；代码中密切相关的部分被更清晰地描绘出来，并且从字面上看更紧密。简单地说，您需要了解的有关 readWords 的所有内容都被命名并包含在一个方法中。即使我选择了一个不太具有描述性的名称，方法 loadProcessAndStore 的整体流程现在也很清楚。此版本中的信息比代码清单 10.1 中的信息更具内聚力。现在，即使代码在功能上相同，代码的哪些部分彼此更密切相关，现在变得更加清晰。所有这些都使这个版本更容易阅读，因此也更容易修改。
请注意，清单 10.2 中有更多的代码行。这个例子是用Java编写的，Java是一种相当冗长的语言，样板成本相当高，但即使没有它，提高可读性的开销也很小。这不一定是坏事！
程序员之间有一个共同的愿望，即减少他们所做的打字量。清晰的简洁是有价值的。如果我们可以简单地表达想法，那么这很有价值，但您不会以输入的最少字符来衡量简单性。 ICanWriteASentenceOmittingSpaces 更短，但读起来也不那么愉快！
优化代码以减少输入是错误的。我们正在优化错误的东西。代码是一种交流工具；我们应该用它来交流。当然，它也需要是机器可读和可执行的，但这并不是它的主要目标。如果是这样，那么我们仍然可以通过拨动计算机前端的开关或编写机器代码来对系统进行编程。
代码的主要目标是将想法传达给人类。我们编写代码来尽可能清晰和简单地表达想法——至少它应该是这样工作的。我们永远不应该以默默无闻为代价选择简洁。在我看来，使我们的代码具有可读性既是专业的注意义务，也是管理复杂性的最重要的指导原则之一。所以我更喜欢优化以减少思考而不是减少打字。
回到代码：这第二个例子显然更具可读性。更容易看出它的意图，它仍然非常可怕，它不是模块化的，没有太多的关注点分离，它对于文件名的硬编码字符串是不灵活的，并且除了运行整个事情之外它是不可测试的和处理文件系统。但是我们提高了内聚力。代码的每一部分现在都专注于任务的一部分。每个部分只能访问完成该任务所需的内容。我们将在后面的章节中回到这个例子，看看我们如何进一步改进它。

## 上下文很重要
我问了一个朋友，他的代码我很欣赏，他是否有任何建议来证明凝聚力的重要性，他推荐了芝麻街 YouTube 视频，2“这些东西中的一个与另一个不同。”
所以这有点像开玩笑，但它也提出了一个关键点。与其他管理复杂性的工具相比，凝聚力是上下文相关的。根据上下文，“所有这些事情可能都不一样。”
我们必须做出选择，而这些选择与其他工具密切相关。我无法清楚地将内聚与模块化或关注点分离分开，因为这些技术有助于定义内聚在我的设计上下文中的含义。
驱动此类决策的一种有效工具是领域驱动设计。3 让我们的思维和设计以问题领域为指导，有助于我们确定从长远来看更有可能盈利的路径。
2. 芝麻街的一首歌，叫做“其中一个不像另一个”：https://youtu.be/rsRjQDrDnY8

3. 领域驱动设计是埃里克·埃文斯 (Eric Evans) 所著一本书的标题，也是一种软件系统设计方法。请参阅 https://amzn.to/3cQpNaL。

> **领域驱动设计**
>
> 领域驱动设计是一种设计方法，我们旨在将代码的核心行为本质上捕获为问题领域的模拟。我们系统的设计旨在准确地对问题进行建模。
> 这种方法包括许多重要的、有价值的想法。
> 它使我们能够减少误解的机会。我们的目标是创建一种“无处不在的语言”来表达问题领域的想法。这是在问题领域中描述想法的一致的、准确的方式，使用一致的词，并具有一致的含义。然后，我们也将这种语言应用于我们谈论系统设计的方式。
> 所以如果我在谈论我的软件并且我说这个“限价单匹配”，那么就代码而言是有道理的，其中“限价单”和“匹配”的概念被清楚地表达出来，并命名为 LimitOrder 和比赛。这些与我们在与非技术人员用业务术语描述场景时使用的词完全相同。
> 这种无处不在的语言通过捕获需求和可以作为“系统行为的可执行规范”的高级测试用例来有效地开发和完善，可以驱动开发过程。
> DDD 还引入了“有界上下文”的概念。这是共享共同概念的系统的一部分。例如，订单管理系统可能与计费系统具有不同的“订单”概念，因此这是两个不同的有界上下文。
> 这是一个非常有用的概念，有助于在设计我们的系统时识别合理的模块或子系统。以这种方式使用有界上下文的一大优势是它们在实际问题域中自然更加松散耦合，因此它们很可能指导我们创建更加松散耦合的系统。
> 我们可以使用无处不在的语言和有界上下文等思想来指导我们系统的设计。如果我们跟随他们的脚步，我们往往会构建更好的系统，他们会帮助我们更清楚地看到系统的核心、基本复杂性，并将其与偶然的复杂性区分开来，否则，它会掩盖我们的代码真正试图实现的目标做。
> 如果我们将系统设计为对问题域的模拟，就我们所理解的而言，那么从问题域的角度来看被视为微小变化的想法也将是代码中的一小步。这是一个很好的财产。
> 领域驱动设计是创建更好设计的强大工具，它提供了一套组织原则，可以帮助指导我们的设计工作，并鼓励我们改进代码中的模块化、内聚性和关注点分离。同时，它引导我们对代码进行粗粒度的组织，这种组织自然更加松散耦合。

另一个帮助我们创建更好系统的重要工具是关注点分离，我们将在下一章中更详细地讨论这一点，但就目前而言，它可能是我最接近指导我自己编程的规则的东西。 “一个班级，一件事；一种方法/功能，一件事。”
到目前为止，我非常不喜欢本章中介绍的两个代码示例，并且有点不好意思向您展示它们，因为我的设计本能在向我尖叫，在这两种情况下，关注点分离都非常糟糕。代码清单 10.2 更好；至少每个方法现在都做一件事，但是这个类仍然很糟糕。如果您还没有看到它，我们将在下一章中了解为什么这很重要。
最后，在我的工具箱中，有可测试性。我开始编写这些糟糕的代码示例，因为我总是在编写代码时开始：通过编写测试。不过，我不得不几乎立即停止，因为我无法练习 TDD 并编写这么糟糕的代码！我不得不放弃测试并重新开始，我承认我觉得我回到了过去。我确实为我的示例编写了测试以检查它们是否符合我的预期，但是此代码无法正确测试。
可测试性强烈鼓励模块化、关注点分离以及我们在高质量代码中重视的其他属性。反过来，这有助于我们对我们喜欢的设计中的上下文和抽象进行初步近似，以及在何处使我们的代码更具内聚力。
请注意，这里没有任何保证，这是本书的最终目的。没有简单的千篇一律的答案。这本书提供了心理工具，可以帮助我们在没有答案时组织我们的思维。
本书中的技巧并不是要为您提供答案；这仍然取决于你。他们更愿意为您提供一系列想法和技术，即使您还不知道答案，也可以让您安全地取得进步。当您创建任何真正复杂的系统时，情况总是如此；在我们完成之前，我们永远不会知道答案！
你可以认为这是一种相当防御性的方法，它确实如此，但目的是让我们的选择自由保持开放。这是努力管理复杂性的重要好处之一。随着我们了解更多，我们可以不断更改我们的代码以反映这种学习。我认为比“防御”更好的形容词是“增量”。
我们通过一系列实验逐步取得进展，我们使用管理复杂性的技术来保护自己不犯太具有破坏性的错误。
这就是科学和工程的工作方式。我们控制变量，迈出一小步，然后评估我们所处的位置。如果我们的评估表明我们走错了一步，那么我们会退后一步，决定下一步要尝试什么。如果看起来没问题，我们控制变量，再迈出一小步，依此类推。
另一种思考方式是软件开发是一种进化过程。作为程序员，我们的工作是通过定向进化的渐进过程指导我们的学习和我们的设计，以获得理想的结果。

## 高性能软件
代码不愉快的常见借口之一（如代码清单 10.1 所示）是，如果您想要高性能，就必须编写更复杂的代码。我职业生涯的后半段时间都在研究处于高性能前沿的系统，我可以向你保证，事实并非如此。高性能系统需要简单、精心设计的代码。
想一想高性能在软件方面意味着什么。为了实现“高性能”，我们需要用最少的指令做最多的工作。
我们的代码越复杂，通过我们代码的路径就越有可能不是最优的，因为通过我们代码的“最简单的可能路径”被代码本身的复杂性掩盖了。对于许多程序员来说，这是一个令人惊讶的想法，但是快速编写代码的途径是编写简单易懂的代码。
当您开始采用更广泛的系统视图时，情况更是如此。
让我们再次回顾我们的琐碎示例。我听说程序员认为代码清单 10.1 中的代码将比代码清单 10.2 中的代码更快，因为代码清单 10.2 增加了方法调用的“开销”。恐怕对于大多数现代语言来说，这是无稽之谈。大多数现代编译器会查看代码清单 10.2 中的代码并内联方法。大多数现代优化编译器会做更多的事情。现代编译器在优化代码以在现代硬件上高效运行方面做得非常出色。它们在代码简单且可预测时表现出色，因此您的代码越复杂，您从编译器的优化器中获得的帮助就越少。一旦代码块的圈复杂度 4 超过某个阈值，编译器中的大多数优化器就会放弃尝试。
我针对此代码的两个版本运行了一系列基准测试。他们不是很好，因为这段代码很糟糕。我们没有充分控制变量以真正清楚地看到正在发生的事情，但显而易见的是，在这个级别的测试中没有真正可测量的差异。
差异太小，无法与这里发生的其他一切区分开来。一方面，BadCohesion 版本是最好的；另一方面，ReallyBadCohesion 是最好的。在一系列基准测试中，对于 loadProcessStore 方法的 50,000 次迭代中的每一次，总体差异不超过 300 毫秒，因此平均而言，每次调用大约有 6 纳秒的差异，实际上更倾向于支持带有附加方法调用的版本。
这是一个糟糕的测试，因为我们感兴趣的东西，方法调用的成本，与 I/O 的成本相形见绌。可测试性——在这种情况下是性能可测试性——再次可以帮助指导我们获得更好的结果。我们将在下一章更详细地讨论这个问题。
“幕后”发生的事情太多了，即使是专家也很难预测结果。答案是什么？如果您真的对代码的性能感兴趣，请不要猜测什么会快，什么会慢；测量它！
4. 用于指示程序复杂性的软件度量。

## 联轴器链接
如果我们想保留探索的自由，有时也会犯错，我们就需要担心耦合的成本。
耦合：给定两行代码 A 和 B，当 B 必须仅因为 A 改变而改变行为时，它们就会耦合。
内聚力：当 A 的更改允许 B 更改以便两者都添加新值时，它们是内聚的。 5
耦合真的是一个太笼统的术语。需要考虑不同类型的耦合（我们将在第 13 章中更详细地探讨这一想法）。
想象一个没有耦合的系统是荒谬的。如果我们希望系统的两个部分进行通信，则它们必须在一定程度上耦合。所以就像内聚一样，耦合是一个程度的问题，而不是任何一种绝对的衡量标准。但是，不适当的耦合级别的成本非常高，因此在我们的设计中考虑它的影响很重要。
耦合在某些方面是凝聚的代价。在您的系统中具有凝聚力的区域中，它们也可能更加紧密地耦合。
用 TDD 驱动高内聚
再次使用自动化测试，特别是 TDD，来驱动我们的设计给我们带来了很多好处。努力为我们的系统实现可测试的设计和良好抽象的、以行为为重点的测试将对我们的设计施加压力，以使我们的代码具有凝聚力。
在编写描述我们打算在系统中观察的行为的代码之前，我们先创建一个测试用例。这使我们能够专注于我们代码的外部 API/接口的设计，无论它是什么。现在我们努力编写一个实现，该实现将满足我们创建的小型可执行规范。如果我们编写了太多代码，超过了满足规范所需的代码，我们就是在欺骗我们的开发过程并降低实现的内聚力。如果我们写得太少，那么行为意图就不会得到满足。 TDD 的纪律鼓励我们找到凝聚力的最佳点。
与以往一样，没有任何保证。这不是一个机械的过程，它仍然依赖于程序员的经验和技能，但这种方法向更好的结果施加压力，这在以前是没有的，并放大了这些技能和经验。
5. 著名的 C2 wiki，https://wiki.c2.com/?CouplingAndCohesion 上描述了耦合和内聚。

## 如何实现有内聚力的软件

内聚力的关键衡量标准是变化的程度或成本。 如果您必须在代码库中四处游荡以在许多地方更改它以进行更改，那么这不是一个非常有内聚力的系统。 内聚力是衡量功能相关性的指标。 它是对目的相关性的度量。 这是滑溜溜的东西！
我们来看一个简单的例子。
如果我创建一个具有两个方法的类，每个方法都与一个成员变量相关联（参见代码清单 10.3），那么内聚性很差，因为变量实际上是不相关的。 它们特定于不同的方法，但在类级别存储在一起，即使它们不相关。
清单 10.3 更差的内聚

```java
class PoorCohesion:    
    def __init__(self):
        self.a = 0
        self.b = 0
    
    def process_a(x):
        a = a + x

    def process_b(x):
        b = b * x
```

代码清单 10.4 展示了一个更好、更有凝聚力的解决方案。 请注意，除了更具凝聚力之外，该版本也更加模块化，并且具有更好的关注点分离。 我们不能回避这些想法的相关性。
清单 10.4 更好的内聚

```java
class BetterCohesionA:   
    def __init__(self):
        self.a = 0

    def process_a(x): 
        a = a + x

class BetterCohesionB:
    def __init__(self):
               self.b = 0
    def process_b(x):
        b = b * x
```

结合我们管理复杂性的其他原则，实现可测试设计的愿望有助于我们提高解决方案的凝聚力。 这方面的一个很好的例子是认真对待关注点分离的影响，特别是在考虑将偶然复杂性 6 与本质复杂性分开时。 7
代码清单 10.5 展示了三个简单的例子，它们通过有意识地专注于分离“基本的”和“偶然的”复杂性来提高我们代码的内聚性。 在每个示例中，我们都将商品添加到购物车，将其存储在数据库中，并计算购物车的价值。
清单 10.5 三个内聚示例

```python
def add_to_cart1(self, item):
    self.cart.add(item)

    conn = sqlite3.connect(‘my_db.sqlite')
    cur = conn.cursor()
    cur.execute('INSERT INTO cart (name, price) 
    values (item.name, item.price)’)
    conn.commit()
    conn.close()
 
    return self.calculate_cart_total();
 
def add_to_cart2(self, item):
    self.cart.add(item)
    self.store.store_item(item)
    return self.calculate_cart_total();
 
def add_to_cart3(self, item, listener):
    self.cart.add(item)
    listener.on_item_added(self, item)
```

第一个函数显然不是内聚代码。这里有许多概念和变量混杂在一起，并且是基本复杂性和偶然复杂性的完整组合。我会说这是非常糟糕的代码，即使在这个本质上是微不足道的规模。我会避免编写这样的代码，因为即使在这种极其简单的规模上，它也会使思考发生的事情变得更加困难。
6. 系统的偶然复杂性是因为我们在计算机上运行而强加给系统的复杂性。它是解决我们感兴趣的实际问题的副作用，例如，持久化信息、处理并发或复杂 API 等问题。

7. 系统的本质复杂性是解决问题所固有的复杂性，例如利率的计算或将商品添加到购物车。

第二个例子要好一些。这样更连贯。此函数中的概念是相关的，并且代表更一致的抽象级别，因为它们主要与问题的基本复杂性相关。 “存储”指令可能是有争议的，但至少我们在这一点上隐藏了意外复杂性的细节。
最后一个很有趣。我认为它肯定是有内聚力的。为了完成有用的工作，我们需要将项目添加到购物车并通知其他可能感兴趣的方添加已完成。我们已经完全分离了存储的问题和计算购物车总数的需要。这些事情可能会发生，以响应添加的通知，或者如果代码的这些部分没有对这个“添加项目”事件感兴趣，它们可能不会发生。
这段代码要么更具内聚力，问题的基本复杂性都在这里，而其他行为是副作用，要么如果您将“存储”和“总计”视为该问题的一部分，则内聚力较低。归根结底，这是基于您正在解决的问题的上下文的上下文和设计选择。

## 内聚差的代价

 内聚力可能是我的“管理复杂性的工具”中最不直接可量化的方面，但它很重要。问题在于，当内聚力很差时，我们的代码和系统就会变得不那么灵活，更难测试，也更难处理。
在代码清单 10.5 的简单示例中，内聚代码的影响是显而易见的。如果代码混淆了不同的职责，它就缺乏 add_to_cart1 所展示的清晰度和可读性。如果职责分布得更广泛，可能更难看到正在发生的事情，如 add_to_cart3。通过将相关的想法紧密联系在一起，我们最大限度地提高了 add_to_cart2 中的可读性。
实际上，add_to_cart3 中暗示的设计风格有一些优点，并且此代码肯定比版本 1 更适合工作。
不过，我在这里的观点是，有内聚力的最佳点。如果你把太多的概念混在一起，你就会在相当详细的层面上失去内聚力。在示例 1 中，您可能会争辩说所有工作都在单个方法中完成，但这只是天真的内聚。
实际上，与将商品添加到购物车相关的概念（功能业务）与其他模糊图片的职责混合在一起。即使在这个简单的例子中，在我们深入研究之前也不太清楚这段代码在做什么。我们必须知道更多的东西才能正确理解这段代码。
另一种替代方法 add_to_cart3 虽然作为设计更灵活，但仍然缺乏清晰度。在这种极端情况下，职责很容易变得如此分散，如此广泛，以至于不阅读和理解大量代码就无法理解图片。这可能是一件好事，但我的观点是，将这种松散耦合的清晰性以及一些好处是有代价的。
这两种故障在生产系统中都极为常见。事实上，它们是如此普遍，以至于它们甚至可能成为大型复杂系统的规范。
这是设计的失败并且付出了巨大的代价。如果您曾经处理过“遗留代码”，那么您就会熟悉这种成本。8
有一种简单的、主观的方法可以发现低内聚力。如果你曾经读过一段代码并认为“我不知道这段代码是做什么的”，那可能是因为内聚力很差。

## 人类系统的内聚

与本书中的许多其他想法一样，内聚问题不仅限于我们编写的代码和我们构建的系统。内聚力是一种在信息层面发挥作用的理念，因此对于让我们工作所在的组织结构合理地构建同样重要。最明显的例子是团队组织。 “DevOps 状态”报告的调查结果表明，以吞吐量和稳定性衡量的高性能的主要预测因素之一是团队能够做出自己的决策，而无需征得团队外任何人的许可.另一种思考方式是团队的信息和技能是有内聚力的，因为团队拥有在其范围内做出决策和取得进展所需的一切。
概括
在管理复杂性的想法列表中，内聚力可能是最糟糕的想法。软件开发人员有时可以而且确实会争辩说，简单地将所有代码放在一个地方、一个文件甚至一个函数中，至少是有内聚力的，但这太简单了。
以这种方式随意组合思想的代码是没有内聚力的；它只是非结构化的。这不好。它使我们无法清楚地看到代码的作用以及如何安全地更改它。
内聚是将相关的概念，一起变化的概念，一起放在代码中。如果他们只是偶然地“在一起”，因为一切都“在一起”，我们并没有真正获得太多的吸引力。
内聚是模块化的反面，在与模块化结合考虑时主要是有意义的。帮助我们在内聚性和模块化之间取得良好工作平衡的最有效工具之一是关注点分离。
8. 遗留代码或遗留系统是已经存在一段时间的系统。它们可能仍然为运营它们的组织提供重要的价值，但它们经常演变成设计糟糕的混乱代码。 Michael Feathers 将遗留系统定义为“没有测试的系统”。
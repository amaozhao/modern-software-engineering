信息隐藏和抽象被定义为“在对象或系统的研究中去除物理、空间或时间细节或属性以将注意力集中在更重要的细节上的过程。”1
在本章的标题中，我将计算机科学中两个略有不同的想法混为一谈；它们不同但相关，为了思考软件工程的基本原则，最好将它们放在一起考虑。

## 抽象或信息隐藏

我将这些想法混为一谈，因为我认为两者之间的差异不足以真正引起我们的关注。我在这里谈论的是在我们的代码中绘制线条或接缝，这样当我们从“外部”查看这些线条时，我们就不会关心它们背后的内容。作为函数、类、库或模块的使用者，我不需要也不关心它是如何工作的，只需要知道我如何使用它。
有些人对信息隐藏的看法比这更狭隘，但我认为它没有增加任何有用的东西。如果您无法摆脱“信息隐藏仅与数据有关”（事实并非如此）的担忧，那么每当我说“信息隐藏”时，请考虑“抽象”。
如果你不能摆脱认为“抽象”的意思只是“创建抽象的概念对象”，那么虽然这是定义的一部分，但它不是我的意思，所以也许可以考虑“信息隐藏”。

1. 来源：维基百科，https://en.wikipedia.org/wiki/Abstraction_(computer_science)

我隐藏的信息是代码的行为。它包括实现细节以及它可能会或可能不会使用的任何数据。我呈现给外部世界的抽象应该实现了对代码的其他部分保密的技巧。
很明显，如果我们的目标是管理复杂性，以便我们可以构建比我们头脑中可以轻松容纳的更复杂的系统，那么我们需要隐藏信息。
我们希望能够专注于我们面前的工作/代码，而不必担心其他地方发生了什么以及我们现在不需要关心的东西如何工作。这看起来很基本，但世界上有很多代码不是这样的。某些代码很容易更改，其中一处更改会影响代码的其他部分。在某些代码中，取得进展的唯一方法就是变得非常聪明，以至于您了解系统的大部分工作方式。这不是一种可扩展的方法！

## 是什么导致“大泥球”？

我们有时将这些难以处理的代码库称为大泥球。它们常常如此纠结、如此复杂，以至于人们害怕改变它们。大多数组织，尤其是大型组织，已经构建了任何时间的软件，都会拥有一些像这样的混乱代码。

## 组织和文化问题
原因复杂多样。我从软件开发人员和软件开发团队那里听到的最常见的抱怨之一是“我的经理不会让我 XXX”，其中“XXX”要么是“重构”、“测试”、“设计得更好”，要么是“修复那个错误。”
世界上肯定有一些令人不快的组织。如果你在这样的地方工作，我的建议是寻找更好的雇主。然而，在绝大多数情况下，这种抱怨根本不真实，或者至少不完全真实。最糟糕的是，这是一个借口。不过，我不喜欢责怪别人，所以更仁慈的解释是，这是基于一个重要的误解。
首先要说的是，我们作为软件开发人员，为什么需要征求许可才能做好？我们是软件开发方面的专家，因此我们最有能力了解哪些有效，哪些无效。
如果你聘请我为你编写代码，我有责任尽我所能做好工作。这意味着我需要优化我的工作，以便我能够在很长一段时间内可靠、可重复和可持续地交付代码。我的代码需要解决我面临的问题，它需要满足我的用户的需求和我雇主的抱负。
因此，我需要创建有效的代码，但我还需要随着时间的推移，可重复且可靠地保持我这样做的能力。当我更多地了解我们正在解决的问题和我们正在开发的系统时，我需要保持修改代码的能力。
如果我是一名在餐厅准备饭菜的厨师，如果我决定在完成后不清理工具和工作区，我可能可以更快地准备一顿饭。这可能对一顿饭有用。它甚至可以用于两餐；这会令人作呕，但它可能会起作用。但是，如果我一直这样工作，我就会被解雇！
我会被解雇，因为我会让餐厅的顾客食物中毒。即使我没有被炒鱿鱼，到我吃到第三顿饭的时候，我的速度也会慢得多，工作效率也会低得多，因为我弄得一团糟会妨碍我的工作。我必须清理一个工作区和我用于每项任务的工具。我不得不与不再锋利的工具作斗争，等等。这听起来很熟悉吗？
如果您聘请我担任厨师，您永远不会说，“您有权磨刀”或“清洁您的工作区域是您的责任”，因为作为一名专业厨师，您和我会假设那些事物是成为专业人士的基本组成部分。作为一名厨师，这将是我的责任的一部分。
作为软件专业人员，我们有责任了解开发软件需要什么。我们需要对我们工作的代码质量负责。做好工作是我们的责任。这不是无私的；它是实用和务实的。这符合我们雇主、用户和我们自己的利益。
如果我们努力创建和维护我们代码的质量，我们的雇主将更有效地获得他们想要的新功能。我们的客户将获得更有意义和更有用的代码，我们将能够进行更改而不会经常担心破坏事物。
这很重要，原因有很多，尤其是因为数据非常清晰。2 软件不是短期获胜的游戏。如果你放弃测试、避免重构，或者不花时间寻找更模块化、更有凝聚力的设计来实现一些短期交付目标，那么你的进展会更慢，而不是更快。
创建软件的组织想要高效地完成它是合理的。有一种经济影响会影响我们为这样一个组织工作的所有人。
如果我们希望我们工作的组织蓬勃发展，并且在构建帮助我们的组织蓬勃发展的软件时让我们拥有更愉快的体验，那么我们需要有效地工作。
我们的目标应该是尽一切努力更快地构建更好的软件。数据在：Accelerate 一书中描述了它所需要的一些东西，当然这并不涉及在质量上天真地偷工减料。反之亦然。
“DevOps 状态”报告的主要发现之一是支持在 Accelerate 书中概述的分析软件团队性能的科学方法的关键发现之一是速度和质量之间没有权衡。如果您在质量方面做得不好，您就不会更快地创建软件。
2. Accelerate 一书描述了采取更严格的开发方法的团队如何比不采取纪律的团队在新工作上花费“多 44% 的时间”。请参阅 https://amzn.to/2YYf5Z8。

因此，当经理要求对一项工作进行估算时，在质量上走捷径不符合您的利益、您的经理的利益或您的雇主的利益。它会让你总体上走得更慢，即使你的经理很愚蠢并认为它会的。
我当然见过有意或无意地向开发人员施加压力以加快速度的组织。然而，通常是开发人员和开发团队共同决定“加速”意味着什么。
通常是开发人员排除质量，而不是经理或组织。管理人员和组织希望“更快地获得更好的软件”，而不是“更快地获得更差的软件”。实际上，即使这样也不是权衡。正如我们已经看到的，在很长一段时间内，真正的权衡是在“更好的软件更快”和“更差的软件更慢”之间。 “更好”与“更快”齐头并进。这对我们所有人都必须承认和相信很重要。最高效的软件开发团队速度并不快，因为他们放弃了质量，而是因为他们接受了质量。
软件工程师的职业职责是认识到这一事实并始终基于高质量的结果提供建议、估计和设计思想。
不要通过解析估计和预测来区分做好工作的时间；假设你的经理、同事和雇主希望你做好工作，然后去做。
工作是有成本的。在烹饪中，部分成本是您在使用过程中清理和维护工具所需的时间。在软件开发中，这些成本包括重构、测试、花时间创建好的设计、发现错误时修复、协作、交流和学习。这些不是“很高兴”的选择；这些是软件开发专业方法的基础。
任何人都可以编写代码；那不是我们的工作。软件开发远不止这些。我们的工作是解决问题，这要求我们在设计中小心翼翼，并考虑我们产生的解决方案的有效性。

## 技术问题和设计问题
假设我们允许自己做好工作，下一个问题是，这需要什么？这确实是本书的主题。第 II 部分中概述的使我们能够优化学习的技术与本部分中描述的技术相结合，为我们提供了使我们能够做得更好的工具。
具体来说，在避免和纠正大泥球的背景下，有一种心态很重要。这是一种心态，认为改变现有代码是一件好事，一件明智的事情。
许多组织要么害怕改变他们的代码，要么对它有某种与现实相悖的崇敬。我会反其道而行之：如果你不能或不会改变代码，那么代码实际上已经死了。再次引用 Fred Brooks 的话：
设计一旦冻结，就会过时。 3

我的朋友丹诺斯谈到了一个有趣的想法。丹 (Dan) 具有以巧妙的措辞捕捉想法的天赋。他谈到“团队的软件半衰期”是衡量质量的一个指标。
现在我和丹都没有任何数据来支持这个想法，但这是一个有趣的想法。他说，一个团队生产的软件的质量是其软件半衰期的函数——也就是说，团队重写他们负责的一半软件所花费的时间。
在 Dan 的模型中，优秀的团队可能会在几个月内重写他们负责的一半软件；低绩效团队可能永远不会改写一半。
现在我很确定丹的想法是非常有背景的；当他提出这个想法时，他在一个非常优秀、快节奏的金融交易团队工作。我同样确信有许多球队不适用这条规则。尽管如此，这里肯定有一定的道理。
如果我们像我所说的那样，是一门根植于我们学习能力的学科，那么当我们学习新事物时，当我们学习改变我们对最佳设计（无论在我们的上下文中意味着什么）的看法时，我们应该能够改变它以反映我们新的、更深入的理解。
当 Kent Beck 为他关于极限编程的名著选择副标题时，他选择了拥抱变化。我不知道他选择那个副标题时的想法是什么，但我开始认为它的含义比我第一次读他的书时想象的要广泛得多。
如果我们认同这一基本理念，即随着我们了解的更多，我们必须保留改变我们的想法、我们的团队、我们的代码或我们的技术的能力，那么我在本书中谈论的几乎所有其他内容都会自然而然地发生。结果。
以让我们犯错并能够纠正错误的方式工作；加深我们对我们面临的问题的理解，并在我们的设计中反映我们的新理解；朝着成功的方向逐步发展我们的产品和技术，无论何时何地——这些都是优秀软件工程的目标。
为了能够做到这一点，我们需要以易于撤消的小步骤进行工作。我们需要我们的代码成为一个适合居住的空间，我们可以在几个月或几年后重新访问，并且仍然可以理解。我们需要能够对代码的一部分进行更改，而不会影响其他部分。我们需要一种方法来快速有效地验证我们的更改是否安全。理想情况下，我们还希望能够随着我们的理解或系统的流行程度的变化而改变我们的一些架构假设。
本书中的所有想法都与此相关，但我觉得抽象或信息隐藏代表了通往宜居系统的最清晰路线。
3. 引用 Fred Brooks 的著作 Mythical Man Month，https://amzn.to/3oCyPeU

> **提高抽象级别**
>
> 获得 Brooksian 数量级的改进需要什么？探索的一种途径是提高编程的抽象级别。
> 在这一思路中，最常见的主题是加强我们有时用来描述系统的高级图表之间的关系。 “如果我画我的系统的图片时，我也可以用那张图片来编写我的系统，那不是很好吗？”
> 多年来，已经有很多尝试实现这一点，并且这个想法的新版本往往会定期出现。在撰写本文时，这种方法的当前化身称为低代码开发。
> 然而，有几个问题似乎妨碍了这种方法。
> 图驱动开发的一种常见方法是使用图生成源代码。这里的想法是使用图表来创建代码的广泛结构，然后可以由程序员手动填写细节。这种策略几乎注定会因一个难以解决的问题而失败。问题在于，随着任何复杂系统的发展，您几乎总是会学到更多。
> 在某些时候，您将需要重新审视您的一些早期想法。这意味着您的图表的第一个版本以及系统的骨架结构是错误的，并且需要随着您理解的加深而改变。 “往返”或为您的代码创建框架、手动修改细节、改变主意、从代码重新生成图表、修改它的能力，但保留详细的更改是一个棘手的问题。到目前为止，所有这些努力都失败了。
> 那么如何完全取消手动编码步骤呢？为什么不使用图表作为代码？这也已经尝试过很多次了。这些类型的系统通常演示得非常好。在构建一些简单的示例系统时，它们看起来非常好且容易。
> 但是，有两个大问题。通过绘制图片而不是编写代码，实际上很难将抽象级别提高到您获得的程度。随着时间的推移，我们已经发展到支持更传统的编程语言，例如异常处理、版本控制、调试支持、库代码、自动化测试、设计模式等，您将失去所有这些优势。
> 第一个问题是为什么这些东西演示得很好，但不能真正扩展到现实世界的系统。问题是，虽然很容易创建一种图形“语言”，让我们简洁地表达简单的问题，但创建一种类似的视觉“语言”要困难得多，它提供了通用工具，允许您创建任何旧作品的逻辑。图灵完备语言实际上是建立在一些极其常见但非常低级的想法之上的。我们描述和编码一个工作的、复杂的软件系统所需的详细程度似乎本质上是复杂和细粒度的。
> 考虑将图形添加到电子表格的需要。大多数电子表格程序提供的工具允许您以图形方式添加图表。您可以在电子表格中选择一些数据的行和列，并选择您要添加的图表类型的图片，对于简单的情况，程序将为您生成一个图表。这些都是很好的工具。
> 但是，如果数据不容易符合简单的预定义模式之一，则情况会变得更加棘手。您的图形要求越具体，您对电子表格中的图形系统的说明就越详细。有时，工具的局限性使它们更难使用而不是更容易。现在，您不仅需要清楚地了解您希望图形如何工作，还需要深入了解如何绕过或应用图形系统开发人员头脑中的编程模型。
> 文本是一种非常灵活、简洁的编码思想的方式。

## 害怕过度设计
许多因素促使开发人员放弃对质量的责任。 其中之一是有效完成工作的压力，无论是真实的还是感知到的。 我听说商业人士担心软件开发人员和团队“过度设计”。 这是一种真正的恐惧，应该归咎于我们技术专业人员。 我们有时会因过度设计而感到内疚。

> **抽象与实用主义**
>
> 我曾经为一个客户做过一个项目，一家大型保险公司。这是一个“救援项目”。我在一家咨询公司工作，这家咨询公司以能够进入并为在以前的尝试中陷入困境或失败的项目提供有效的解决方案而闻名。
> 这个项目失败得相当惊人，两次。它已经开发了三年多，他们没有任何可以使用的东西。
> 我们开始工作并在替代品方面取得了不错的进展。一位来自“战略小组”或类似名称的建筑师与我们接洽。他坚持我们的软件必须符合“全球架构”。因此，作为该项目的技术负责人，我研究了这会带来什么。
> 他们对分布式、基于服务的组件架构有一个宏伟的计划，该架构抽象了他们的整个业务。他们为技术事物以及领域级别的有用行为提供服务。他们的基础设施将负责安全性和持久性，并允许企业中的系统彼此完全集成。
> 到现在为止，我相信你怀疑，这都是蒸汽器具。他们有很多文档和相当数量的代码，但在我看来并没有奏效。这个项目是由一个 40 多人的团队建造的，大约晚了三四年。所有项目都被要求使用这个基础设施，但从来没有一个项目这样做过！
> 这听起来很神奇，因为它很神奇；这是想象中的。
> 我们礼貌地拒绝并完成了我们正在构建的系统，而没有使用该架构中的想法或技术。
> 在纸面上，架构看起来不错，但在实践中，这只是理论。

我们是技术专家。因此，我们有一些共同的倾向。我们应该注意并防范的其中一种趋势是追逐“技术上闪亮的想法”。我和任何对技术想法感兴趣的人一样内疚。这是我们学科吸引力的一部分，我们重视这种学习。但是，如果我们要成为工程师，就必须采取一定程度的实用主义，甚至是怀疑主义。在本书的开头，我对工程的部分定义包括“在经济限制内”这个短语。我们应该始终考虑通往成功的最简单途径，而不是最酷的途径，而不是可以添加到我们的简历或简历中的最多技术的途径。
无论如何，要跟上新的想法。了解我们工作中的新技术或方法，但始终在您尝试解决的问题的背景下诚实地评估它们的使用。如果您正在应用这项技术或想法来了解它是否有用，那么请认识到这一事实，并以试验、原型或实验的形式快速有效地进行探索，而不是作为新架构的基石，未来公司视情况而定。如果它不起作用，请准备好丢弃它，并且不要冒险在看起来很酷的技术上进行整个开发。
根据我的经验，如果我们认真对待“追求简单”的想法，我们最终会做一些很酷的事情，而不是更少。我们也更有可能提高简历和简历的价值。
还有另一种方式，我们经常被引诱过度设计我们的解决方案。那是为了使它们面向未来。如果你曾经说过或想过，“我们现在可能不需要这个，但我们将来可能会需要”，那么你就是“面向未来的”。我和过去的任何人一样对此感到内疚，但我已经开始将其视为设计和工程不成熟的标志。
我们尝试这种面向未来的设计，为我们提供一些保险，使我们能够应对未来的增强或需求变化。这是一个很好的目标，但错误的解决方案。
再次参考 Kent Beck 的 Extreme Programming Explained 一书，他向我介绍了以下概念：
> YAGNI：你不需要它！

Kent 的建议是，我们应该编写代码来解决我们现在面临的问题，而且仅此而已。我强烈重申这一建议，但它是更大整体的一部分。
正如我在本书中多次说过的那样，软件是一种奇怪的东西。它几乎具有无限的灵活性，而且极其脆弱。我们可以在软件中创建我们想要的任何构造，但是当我们更改它时，我们冒着破坏该构造的风险。人们在过度设计他们的解决方案时试图解决的问题是，他们试图对未来进行验证，他们对更改代码感到紧张。
为了应对这种紧张，他们现在正试图及时修复设计，同时他们也在关注它。他们的目标是他们将来不需要重新审视它。如果你已经读完这本书，你现在就会知道我认为这是一个非常糟糕的主意，那么我们可以做些什么呢？
我们可以接近代码的设计，以便我们可以在将来学习新东西并对其进行更改时随时返回到它。我们可以利用这种近乎无限的灵活性。现在我们需要解决的问题是我们代码的脆弱性。
怎样才能让我们有信心在未来可以安全地更改我们的代码？有三种方法，其中一种是愚蠢的。
我们可以非常聪明，以至于我们完全理解代码及其所有含义和依赖关系，以便我们可以安全地进行更改。这是英雄程序员模型，虽然这是愚蠢的模型，但据我所知，这也是更常见的策略之一。
大多数组织通常只有少数人“英雄”4，他们会在出现问题时被要求“挽救局面”，或者被要求进行需要进行的棘手更改。如果您的组织中有一位英雄，她需要努力传播她的知识并与其他人合作以使系统更易于理解。这比“英雄”更常见的更常见的消防更有价值。
害怕改变我们的代码问题的真正解决方案是抽象和测试。如果我们抽象我们的代码，根据定义，我们就是在隐藏系统某一部分的复杂性。这意味着我们可以更安全地更改系统某一部分的代码，并且更加确信我们的更改，即使是错误的，也不会对其他部分产生不利影响。为了更确定这一点，我们还需要测试，但通常测试的价值并不那么简单。

## 通过测试改进抽象
在图 4.2 中，我展示了一个扁平化的变更成本图，代表了我们希望能够随时进行任何变更的理想情况，在时间和精力方面的成本大致相同。
4. 在 Gene Kim 的书《凤凰计划》中有一个可爱的虚构例子，其中角色 Brent Geller 是唯一可以挽救这一天的人。

为了实现这种平坦的变更成本曲线，我们需要一种有效、高效的回归测试策略，这实际上意味着回归测试的完全自动化策略。进行更改，并运行测试，以便您可以看到哪里出错了。
这个想法是持续交付的基石之一，也是我所知道的工程方法最有效的起点。我们努力使我们的软件“始终处于可发布状态”，并且我们通过高效、有效、自动化的测试来确定“可发布性”。
然而，测试的另一个方面很重要，不仅仅是发现我们的错误，如果人们从未以这种方式工作过，他们就更难发现。
这就是我之前描述的可测试性对设计的影响。我们将在第 14 章中更深入地探讨这个想法。 但是，具体而言，在抽象的上下文中，如果我们将测试作为代码所需行为的微型规范，那么我们就是从外部描述该所需行为——在。
完成工作后不写规范；在开始之前你需要它们。因此，我们将在编写代码之前编写我们的规范（测试）。由于我们没有代码，我们的重点更明确地集中在让我们的生活更轻松上。在这一点上，我们的目标是尽可能简单地表达规范（测试）。
不可避免地，我们正在，或者至少应该，从我们的代码从消费者的角度，尽可能清晰和简单地表达我们对我们想要的行为的渴望。此时我们不应该考虑实现该迷你规范所需的实现细节。
如果我们遵循这种方法，那么根据定义，我们就是在抽象我们的设计。我们正在为我们的代码定义一个接口，它可以轻松表达我们的想法，以便我们可以很好地编写我们的测试用例。这意味着我们的代码也很容易使用。编写规范（测试）是一种设计行为。我们正在设计我们期望程序员如何与我们的代码交互，与代码本身的工作方式分开。所有这些都是在我们了解代码的实现细节之前。这种基于抽象的方法帮助我们将代码需要做什么和它如何做分开。在这一点上，我们很少或根本不说我们将如何实施该行为；以后再说。
这是一种实用、务实、轻量级的合同设计方法。 5

## 抽象的力量
作为软件开发人员，作为消费者，我们都熟悉抽象的力量。当我们成为软件生产者时，尽管许多开发人员在他们自己的代码中很少关注抽象。
与其现代的后继者相比，早期的操作系统在硬件抽象方面并没有太多的障碍。现在，如果我想更改 PC 中的视频卡，有一整套抽象可以将我的应用程序与此类更改隔离开来，因此我可以确信我的应用程序很可能会继续工作并显示内容.
5. 契约式设计是一种专注于契约的软件设计方法，契约是系统或其组件支持的规范。请参阅 https://en.wikipedia.org/wiki/Design_by_contract。

现代云供应商正忙于抽象出运行复杂、分布式、可扩展应用程序的大部分操作复杂性。像 Amazon Web Service 的 S3 这样的 API 看似简单。我可以提交任何字节序列以及可用于检索它的标签以及将其放入的“存储桶”的名称，AWS 会将其分发到世界各地的数据中心，并提供给任何人允许访问它并提供服务级别协议，以确保在除最灾难性事件之外的所有事件中保留访问权限。这是抽象一些相当复杂的东西！
抽象也可以代表更广泛的组织原则。语义标记的数据结构，如 HTML、XML 和 JSON，在通信中非常流行。有些人说他们更喜欢它们，因为它们是“纯文本”，但事实并非如此。毕竟，纯文本对计算机意味着什么？最后都是电子流过晶体管，电子和晶体管也是抽象的！
HTML 或 JSON 对于在不同代码模块之间发送的消息的吸引力在于，数据的结构在通信中是明确的，并且模式与内容一起传输。我们可以使用其他性能更高的机制来做到这一点，例如 Google 的 Protocol Buffers6 或 SBE,7，但大多数情况下我们不会这样做。
开发人员真的很喜欢（实际上）像 JSON 或 HTML 这样效率极低的机制，因为一切都可以与它们一起使用。这是因为另一个重要的抽象：纯文本。纯文本不是纯文本，也不是文本；它是一个协议和一个抽象，它允许我们处理信息而不必过多担心信息是如何组织的，而不是在一些非常基本的层次上将其表示为字符流。尽管如此，它仍然是一种抽象，它对我们隐藏了信息。
这种“纯文本”生态系统在计算中无处不在，但它不是自然的，也不是不可避免的。人们设计了它，它随着时间的推移而发展。我们需要就字节顺序和编码模式等问题达成一致。所有这一切都发生在我们甚至开始考虑底层抽象之前，通过这些抽象，我们可以了解运行软件的硬件。
“纯文本”抽象是一种非常强大的抽象。另一个极其强大的抽象是计算中的“文件”抽象，在一切都是文件的 Unix 计算模型中达到了它的高度。通过将文件从一个模块的输出“管道”到另一个模块的输入，我们可以连接逻辑以构建新的、更复杂的系统。所有这些都是“编造”出来的，只是想象和组织实际情况的一种有用方式。
6. Google 的 Protocol Buffers 旨在成为更小、更快、更高效的 XML 版本。在 https://bit.ly/39QsPZH 阅读更多内容。

7. 简单二进制编码 (SBE) 用于金融。它是一种二进制数据编码方法，允许您定义数据结构并生成代码以在任一端转换它们。它共享其他语义数据编码方法的一些属性，但性能开销较低。在此处阅读更多信息：https://bit.ly/3sMr88c。

抽象是我们处理计算机能力的基础。它们也是我们理解和处理我们为计算机增值而创建的系统的能力的基础。查看我们在编写软件时所做的事情的一种方法（并且这是我们在某些方面所做的唯一事情）是创建新的抽象。关键是要创造好的。

## 泄漏的抽象
泄漏抽象被定义为“泄漏了它应该抽象掉的细节的抽象”。
这个想法被 Joel Spolsky 推广，他接着说：
所有非平凡的抽象都是有漏洞的。 8

我偶尔会听到人们为糟糕的代码辩解，说“所有的抽象都是有漏洞的，所以为什么要麻烦？”好吧，这完全忽略了原始帖子和一般抽象的要点。
没有抽象，计算机和软件就不会存在。 “泄漏抽象”的想法并不是反对它们的论据。相反，它描述了抽象是我们需要照顾的复杂事物。
也有不同种类的“泄漏”。存在无法避免的泄漏，对此最有效的方法是仔细考虑它们并努力将其影响降到最低。例如，如果你想构建一个低延迟系统，以“尽可能接近硬件的极限”处理数据，那么“垃圾收集”和“随机存取存储器”的抽象将进入因为它们在时间方面泄漏，通过使延迟成为变量。现代处理器比 RAM 快数百倍，因此如果您关心时间，访问不是随机的。时间上有不同的成本，具体取决于在哪里您想要处理的信息来自。因此您需要优化以利用硬件；您需要了解其抽象、缓存、预取周期等，并在您的设计中允许它们，如果您想最小化泄漏的影响。
另一种泄漏实际上是您的抽象试图传达的错觉崩溃的一个点，因为您没有时间、精力或想象力来满足您的设计中断。
将功能故障报告为 HTML 错误的授权服务和返回 NullPointerExceptions 的业务逻辑模块都因技术故障而破坏了业务级抽象。这两者都是抽象意在传达的幻觉连续性的一种中断。
通常，通过尽可能保持一致的抽象级别来尝试应对第二种泄漏。作为某种 Web 服务公开的远程组件通过 HTML 报告通信失败可能是可以接受的；这是网络和通信抽象技术领域的问题，而不是服务本身的问题。错误是将 HTML 错误代码用于服务的业务级故障。这是抽象的突破。
8. 您可以在此处阅读 Joel Spolsky 的原始帖子：https://bit.ly/2Y1UxNG。

对此的一种看法是，抽象，所有的抽象，基本上都是关于建模的。我们的目标是为我们的问题创建一个模型，帮助我们推理它并帮助我们完成工作。我喜欢 George Box 的这句话：
所有模型都是错误的，有些模型是有用的。9

这始终是我们所处的情况。无论我们的模型有多好，它们都是真实的表现，而不是真实本身。即使在根本上不真实的情况下，模型也可能非常有用。
我们的目标不是实现完美，而是实现有用的模型，我们可以将其用作解决问题的工具。

## 选择合适的抽象
我们选择的抽象的性质很重要。这里没有普遍的“真理”；这些是模型。
一个很好的例子是地图（人类的“地图”，而不是计算机语言数据结构）。当然，所有地图都是现实世界的抽象，但根据我们的需要，我们有不同类型的抽象。
如果我想驾驶一艘船或一架飞机到达目的地，那么有一张地图可以让我测量两点之间的路线是很有用的。 （严格来说，这种地图称为图表，这意味着我可以在图表上测量“方位角”，如果我转向那个方向，我就会到达正确的位置。）恒方位角图表的概念1569年由墨卡托发明。
不会用太多细节让您感到厌烦，恒定轴承图表基于称为 Rhumb-lines 的东西。您可以在这种地图上测量方位，如果您从 A 点开始并航行（或飞行）该方位，您将在 B 点结束。
现在，众所周知，世界不是平面。它是一个球体，所以实际上这不是 A 和 B 之间的最短距离，因为在球体的表面上两点之间的最短距离是一条曲线，这意味着方位在不断变化。因此，图表的抽象隐藏了更复杂的曲面数学，并提供了一个实用的工具，我们可以用它来规划我们的课程。
这种抽象泄露的事实是，您旅行的距离比绝对必要的要长，但由于我们正在优化易用性，因此在计划和航行时，一切都很好。
9. 引用统计学家 George Box 的话，虽然这个想法比较古老。请参阅 https://bit.ly/2KWUgbY。

大多数地下火车地图使用完全不同的抽象。这是哈里·贝克于 1933 年发明的。
哈利的地图已成为设计经典，这个想法在世界各地被用来描绘如何在地下火车网络上出行。哈利意识到，在乘坐伦敦地铁（伦敦的地下系统）时，您并不关心在途中的位置。因此，他构建了一张与自然地理没有真正关系的网络拓扑精确地图。
这种风格的地图，这种抽象，让乘客可以非常清楚地看到哪些火车开往哪些车站，哪些车站与其他线路有联系。但是如果你试图用它在车站之间行走，抽象就会崩溃。有些车站相距数步之遥，但相距甚远；其他人看起来很近，但很远。
我的观点是，对于同一件事可以有不同的抽象——甚至是不同的抽象。如果我们的任务是在伦敦地铁的车站之间铺设网络电缆，我们会愚蠢地选择哈利的地图。但是，如果我们想从阿森纳地铁站前往莱斯特广场吃晚饭，那么选择地理图表就太愚蠢了。
抽象及其核心的建模是设计的基础。抽象越有针对性地解决您要解决的问题，设计就越好。请注意，我没有说“抽象得越准确”。正如哈利的地铁图清楚地表明的那样，抽象不需要非常准确就非常有用。
再一次，可测试性可以在我们尝试提出有用的抽象时为我们提供早期反馈和灵感。
反对单元测试、有时也反对 TDD 的常见论点之一是，测试和代码变得“锁定在一起”，一切都变得更加难以改变。这更多是对单元测试的批评，其中测试是在代码完成后编写的。不可避免地，此类测试与被测系统紧密耦合，因为它们是作为测试而不是规范编写的。正如我所描述的，TDD 受此问题影响较小，因为我们首先编写测试（规范），然后将问题抽象化。
然而，这里的微妙之处以及 TDD 提供的巨大价值在于，如果我编写了抽象规范，关注代码应该做什么而不是它如何实现该结果，那么我的测试所表达的就是我的抽象。所以如果测试在变化面前是脆弱的，那么我的抽象在变化面前是脆弱的。所以我需要更深入地思考更好的抽象。我知道没有其他方法可以获得这种反馈。
下一章讨论耦合。不恰当的耦合是软件开发面临的最重大挑战之一。本书的整个部分实际上是关于允许我们管理耦合的策略。问题是天下没有免费的午餐。过于抽象的设计可能与抽象不足的设计一样痛苦。它们可能效率低下并带来不必要的开发和性能成本。所以，有一个甜蜜点可以击中，我们系统的可测试性是我们可以用来击中它的工具。
总的来说，我们的目标应该是保持我们改变想法的能力，并尽可能地进行我们的设计，而不需要太多额外的工作。这里没有固定的食谱。这是优秀软件开发的真正技能，它来自实践和经验。我们需要建立我们的直觉，以便能够发现设计选择，这些选择将限制我们以后改变主意的能力，并使我们能够保持我们的选择。
这意味着我在这里提供的任何建议都是上下文相关的。但是，这里有一些指导方针，而不是规则。

## 问题域的抽象

对问题域进行建模将为您的设计提供一些指导。这将使您能够自然地实现问题域的关注点分离，并帮助您，甚至可能迫使您更好地理解您正在尝试解决的问题。诸如事件风暴10 之类的技术是绘制问题范围的一个很好的起点。
事件风暴可以帮助您识别可能代表感兴趣概念的行为集群，并且有趣的概念是您设计中模块或服务的良好候选者。它可以突出问题域中的有界上下文和自然抽象线，与其他更具技术性的部门相比，它们往往更容易相互分离。

> **领域特定语言**
>
> 在提高抽象级别方面肯定更有希望的一个想法是领域特定语言 (DSL) 的想法。但是，根据定义，DSL 不是通用的。有意地，它的重点更窄，也可以更抽象，隐藏细节。
> 当我们看到图表驱动的开发系统演示时，这就是我们真正看到的效果。我们看到了 DSL（在这种情况下是图形化的）对解决范围狭窄的问题的影响。在这个领域，这些更受约束的表达想法的方式非常强大和有用。
> DSL 是一个非常有用的工具，在开发强大的，甚至可能是“用户可编程”的系统方面发挥着重要作用，但它与通用计算不是一回事，所以它不是本书的真正主题；因此，我们将把它留在那里，但简而言之，没有比创建 DSL 更好的方法来创建有效的测试用例，该 DSL 允许您将系统的理想行为表达为“可执行规范”。

10. 事件风暴是由 Alberto Brandolini 发明的一种协作分析技术，它允许您对问题域内的交互进行建模。参见 http://bit.ly/3rcGkdt。

## 抽象的偶然复杂性

软件在计算机上运行。计算机的工作方式呈现出我们不得不与之抗衡的一系列抽象和约束。其中一些是深入的，在信息和信息理论的层面上，比如并发和同步与异步通信。其他的则更多是硬件实现特定的，例如处理器缓存架构，或者 RAM 和离线存储之间的区别。
除了最琐碎的系统之外，您不能忽略这些事情，并且根据您的系统的性质，您可能需要非常深入地考虑它们。然而，这些是不可避免地会泄漏的抽象。如果网络出现故障，您的软件最终会受到影响。
总的来说，在我的设计中，我的目标是尽可能抽象出偶然复杂性领域和本质复杂性（问题领域）领域之间的接口。这确实需要一些良好的设计思维和一些像工程师一样的思维。
开始的问题是，我如何在本质复杂性域中表示偶然复杂性世界？我的系统的逻辑需要了解它运行的计算机的哪些信息？我们应该努力使这些知识最小化。
代码清单 12.1 展示了第 10 章中内聚的三个例子。如果我们从抽象的角度以及分离偶然复杂性和本质复杂性的角度来看这些，我们可以获得更多的洞察力。
清单 12.1 三个内聚示例（再次）

```python
def add_to_cart1(self, item):
    self.cart.add(item)
 
    conn = sqlite3.connect('my_db.sqlite')
    cur = conn.cursor()
    cur.execute('INSERT INTO cart (name, price) values (item.name, item.price)')
    conn.commit()
    conn.close()
 
    return self.calculate_cart_total();
 
def add_to_cart2(self, item):
    self.cart.add(item)
    self.store.store_item(item)
 
    return self.calculate_cart_total();
 
def add_to_cart3(self, item, listener):
    self.cart.add(item)
    listener.on_item_added(self, item)
```

第一个示例 add_to_cart1 根本没有抽象，因此有点混乱。
下一个 add_to_cart2 更好。我们添加了一个用于存储信息的抽象。我们在我们的代码中创建了一个名为 store 的“接缝”，这使得代码更具凝聚力，在我们领域的基本功能之间的关注点分离中划出了一条清晰的线，将商品添加到购物车，以及计算总计和由于我们的计算机区分了易失性但快速的 RAM 和速度较慢但非易失性的磁盘这一事实而导致的意外复杂性。
最后，在 add_to_cart3 中，我们有一个抽象，使我们的基本复杂性代码不受影响。我们的抽象是完整的，在引入对所发生的事情感兴趣的东西的想法方面略有让步，听众。
就抽象的一致性而言，add_to_cart3 在我看来是最好的。甚至存储的概念也已被删除。
这种抽象的美妙之处在于模型是多么干净，因此可以很容易地测试它或使用 on_item_ added 的新行为来增强此代码。
这种抽象的成本，可能妨碍 add_to_cart3 成为最佳选择的泄漏，提出了一个问题，如果尝试存储失败会发生什么？如果我们的数据库连接池中的连接耗尽或我们的磁盘空间不足或我们的代码和数据库之间的网线被意外挖出会发生什么？
第一个例子不是模块化的，它缺乏凝聚力，将偶然和本质的复杂性混为一谈，没有关注点分离；这仍然只是糟糕的代码！
其他两个更好，不是出于任何人为的美或优雅概念，而是出于实用、务实的原因。
由于关注点分离和我们选择的抽象，版本 2 和 3 更灵活、耦合更少、更模块化、更具凝聚力。这两者之间的抽象选择实际上是一种设计选择，应该由此代码所在的上下文驱动。
我们可以想象几种方法来实现这一点。
例如，如果存储空间的缺乏与将商品添加到购物车有关，那么我们需要撤消对购物车的更改。这是令人不快的，因为存储的技术性正在侵入我们以前的纯抽象。也许我们可以努力限制泄漏的程度；看看代码清单 12.2。
清单 12.2 减少抽象泄漏

```python
def add_to_cart2(self, item):
    if (self.store.store_item(item))
        self.cart.add(item)
 
    return self.calculate_cart_total()
```

在代码清单 12.2 中，我们退出了完全抽象的版本 3，并允许“存储”的概念存在于我们的抽象中。我们已经用成功或失败的返回值表示了存储和将项目添加到购物车之间关系的事务性质。请注意，我们不会通过返回特定于实现的错误代码并将其泄漏到我们的域级抽象中来混淆我们的抽象。我们已将故障的技术性质限制为布尔返回值。这意味着捕获和报告错误的问题在其他地方处理，在我们的“存储”实现中，在这种情况下。
这是我们试图将抽象中不可避免的泄漏的影响最小化的另一个例子。我们也在对失败案例进行建模并对其进行抽象。现在我们可以再次想象“商店”的各种实现。因此，我们的代码更加灵活。
或者，我们可以采取更轻松、解耦的观点。在代码清单 12.1 的 add_to_cart3 中，我们可以想象在 on_item_add 事件背后有一些“保证”。11 假设如果由于某种原因 on_item_add 失败，它将被重试，直到它起作用为止。 （实际上我们希望比这更聪明，但为了让我的例子简单起见，让我们坚持下去！）
现在我们确信，在未来的某个时刻，“商店”或任何其他响应 on_item_ added 的东西都会被更新。
这无疑增加了 on_item_add 下的通信的复杂性，但它更强烈地保留了我们的抽象，并且根据上下文，可能值得额外的复杂性。
我对这些示例的目标不是详尽地探索所有选项，而是展示我们可能选择进行的一些工程权衡，具体取决于我们系统的上下文。
我所提到的“像工程师一样思考”，并在这里理想地展示了，是在思考事情可能出错的方式。您可能还记得，玛格丽特·汉密尔顿 (Margaret Hamilton) 在发明软件工程一词时将其描述为她方法的基石。
在这个例子中，我们想象了如果存储失败会发生什么。我们发现在那种情况下我们的抽象泄露了。所以我们不得不多想一点，想出几种不同的方法来应对泄漏。

## 隔离第三方系统和代码
add_to_store 的第 1 版与第 2 版和第 3 版之间的另一个明显区别是，第 1 版公开了我们的代码并将其耦合到特定的第三方代码，在本例中为 sqlite3。这是 Python 世界中的一个通用库，但即便如此，我们的代码现在还是具体绑定到了这个特定的第三方库。此代码在三者中最糟糕的另一个原因是与此第三方代码的耦合。
11. 计算机科学家会非常正确地告诉您，不可能提供“保证交付”。他们的意思是你不能保证“恰好一次交付”，但我们可以解决这个问题。参见 https://bit.ly/3ckjiwL。

删除谈论 sqlite3、连接和插入子句的代码块，并将其移到其他地方，远离我不关心任何这些东西的代码，这是向前迈出的一大步走向更大的普遍性。对于这么少的工作来说，这是一个很大的收获。
一旦我们允许第三方代码进入我们的代码，我们就会与之耦合。一般而言，我的偏好和建议是始终使用您自己的抽象将您的代码与第三方代码隔离。
在我们继续这个想法之前，有一些警告。显然，您的编程语言及其通用支持库也是“第三方代码”。我并不是建议您为字符串或列表编写自己的包装器，所以像往常一样，我的建议是一个指导方针，而不是一个硬性规定。但是，我建议您仔细考虑在代码“内部”允许的内容。我的默认立场是，我将允许标准的语言概念和库，但不允许任何非我的语言附带的第三方库。
我使用的任何第三方库都将通过我自己的外观或适配器进行访问，这些外观或适配器将抽象并简化我的接口，并在我的代码和库中的代码之间提供一个通常非常简单的隔离层。出于这个原因，我倾向于警惕那些试图将其编程模型强加给我的包罗万象的框架。
这听起来可能有点极端，也可能是极端的，但这种方法意味着我的系统因此更具可组合性和灵活性。
即使在我们在这里看到的简单示例中，add_to_cart2 也提供了一个在我的存储实现上下文中有意义的抽象。我可以提供一个版本，它本质上是从 add_to_store1 在 sqlite3 中实现存储的代码块，但我也可以编写完全不同类型的存储，而无需以任何方式修改 add_to_cart2 实现。我可以在不同的场景中使用相同的代码，我什至可以编写某种复合版本的 store，在需要时将我的物品存储在多个地方。
最后，我们可以针对这种抽象来测试我们的代码，它总是比真实的东西更简单的版本。因此，如果我犯了错误，我的解决方案将更加灵活，并且更容易更改，只需很少的额外工作。

## 总是喜欢隐藏信息
另一个强有力的指导方针帮助我们引导我们的代码朝着一个方向保持未来变化的大门，而不破坏 YAGNI，是更喜欢更一般的表示而不是更具体的表示，但这有点过于简单化的建议。 这个想法最清晰的演示可能是通过函数和方法签名。
代码清单 12.3 展示了函数签名的三个版本。 其中一个在我看来比其他的要好得多，尽管像往常一样，它是有上下文的。
清单 12.3 优先隐藏信息

```java
public ArrayList<String> doSomething1(HashMap<String, String> map);

public List<Sting> doSomething2(Map<String, String> map);

public Object doSomething3(Object map);
```

第一个过于具体。当我收集返回值时，我真的关心它是一个 ArrayList 而不是任何其他类型的 List 吗？我想，当我关心时，我可以想象出极少的情况，但总的来说，我宁愿不在意。我几乎肯定感兴趣的是 List-yness，而不是 ArrayList-yness！
“好的，”我听到你哭了。 “所以总是喜欢最抽象、最通用的表现形式。”嗯，是的，但在保持抽象的合理范围内。我会愚蠢地遵循这个建议并创建版本 doSomething3 的相当不愉快的函数签名。这是通用的，可能没有帮助。同样，有时 Object 是正确的抽象级别，但这些是或应该是罕见的，并且始终处于偶然而非本质的复杂性领域。
所以，总的来说，doSomething2 可能是我最常见的目标。我足够抽象，我不会太依赖于 doSomething1 的技术特性，但我也足够具体，可以帮助呈现和维护一些关于如何使用我产生的信息以及我对我使用的信息的期望的指示.
我相信你现在已经厌倦了我重复这个，但是再一次，通过设计可测试性来增强我们为我们的抽象确定最佳点的能力。尝试编写测试并模拟我们正在创建的接口的使用，让我们有机会体验和锻炼我们对被测代码的接口的理解。
这一点，再加上我们倾向于隐藏一般信息，以及更喜欢我们处理的在我们的上下文中有意义的信息的更通用的表示，将再次帮助我们保持未来变革的大门。

## 概括

抽象是软件开发的核心。对于有抱负的软件工程师来说，这是一项至关重要的技能。我的大多数示例可能都是面向对象的，这是因为我倾向于这样考虑代码。然而，这对于函数式程序员甚至汇编程序编程都是如此。我们的代码，无论其性质如何，当我们在其中构建隐藏信息的接缝时会更好。
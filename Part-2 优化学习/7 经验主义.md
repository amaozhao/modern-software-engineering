在科学哲学中，经验主义被定义为“强调证据，尤其是在实验中发现的证据。所有假设和理论都必须根据对自然世界的观察进行检验，而不是仅仅依赖于先验推理、直觉或启示，这是科学方法的基本组成部分。”1
根据这个定义，经验主义与实验密切相关。然而，我将这两个概念都保留在我的五个列表中，因为实验可以在这样的受控环境中进行，我们可以很容易地尝试在工程意义上无法转化为有意义的现实的想法。
即使在现代物理工程中，使用我们所有的计算机模型和模拟，我们仍然看到工程师测试他们创造的东西，通常是破坏，以了解他们的模拟有多准确。经验主义是工程学的一个重要方面。
对于那些对在某个语义针的头上计算天使不太感兴趣的读者来说，这有什么关系呢？
与纯科学不同，工程学牢固地植根于将思想应用于解决现实世界问题的应用。我可以很容易地决定我需要实现一些架构纯度的目标或一些要求我发明和探索软件新技术的性能目标，但除非这些想法以某种有形的价值实现，除非我的软件可以做更多重要的事情或提供新的价值，无论我对它们进行了多少试验，它们都无关紧要。
1. 来源：维基百科，https://en.wikipedia.org/wiki/Empiricism

## 立足于现实

另一个方面是我们的生产系统总是会给我们带来惊喜，他们应该！理想情况下，它们不会经常以非常糟糕的方式让我们感到惊讶，但到目前为止，任何软件系统实际上只是其开发人员的最佳猜测。当我们将我们的软件发布到生产环境中时，这就是或者应该是一个学习的机会。
这是我们可以从其他学科的科学和工程中学到的重要一课。用科学、理性的方法解决问题的一个非常重要的方面是怀疑论的思想。谁有一个想法，我们多么希望这个想法是真实的，或者我们为一个想法投入了多少工作，都无关紧要；如果这个想法不好，那就不好。
观察软件产品选择的影响的证据表明，对于最好的公司来说，只有一小部分想法会产生他们预测的效果。
构建功能是因为团队相信它们是有用的，但在许多领域，大多数想法都未能改进关键指标。在 Microsoft 测试的想法中，只有三分之一改进了它们旨在改进的指标。 2

经验主义，根据证据和对现实的观察做出决定，对于取得合理的进展至关重要。如果没有这种分析和反思，组织将继续在猜测的基础上继续前进，并将继续投资于失去金钱或声誉的想法。

## 将经验与实验分开
我们可以通过使用我们作为实验的一部分收集的信息来做出决策来进行实证。我们将在下一章探讨这个方面。我们也可以通过不那么正式地观察我们想法的结果来进行实证。这不是实验的替代，而是当我们考虑下一个实验时，我们可以提高对当前情况的表征质量的一种方式。
我知道，在分别探索经验主义和实验的思想时，我有陷入哲学和词源学奥秘的危险。这不是我的意图，所以让我通过实际例子来说明为什么值得独立考虑这两个密切相关的想法。
“我知道那个虫子！”
几年前，我有过从零开始建立世界上表现最好的金融交易所之一的奇妙经历。正是在我职业生涯的这段时间里，我开始在我的软件开发方法中认真对待工程思维和纪律。
2. 在一篇题为“大规模在线实验”(https://stanford.io/2LdjvmC) 的论文中，作者描述了三分之二到三分之二的软件变更想法如何为组织产生零或负值实施了它们。

当我们发现一个严重的错误时，我们正准备将其发布到生产环境中。这对我们来说是一个相对不寻常的事件。该团队采用了本书中描述的原则，包括持续交付，因此我们对小变化的持续流有持续的反馈。我们很少在当天晚些时候发现大问题。
我们的候选版本在发布前正在接受最终检查。当天早些时候，我们的一位同事 Darren 在站立时告诉我们，在运行我们的 API 验收测试套件时，他在他的开发工作站上看到了一个奇怪的消息传递失败。他显然看到了在我们的底层第三方发布订阅消息代码中被阻止的线程。他试图复制它，并且可以，但他只能在一个特定的配对站上这样做。这很奇怪，因为我们的环境配置是完全自动化的，并且使用相当复杂的基础设施即代码方法进行版本控制。
那天下午晚些时候，我们开始了下一组更改的工作。几乎立即，我们的构建网格出现了戏剧性的变化，许多验收测试失败了。我们开始探索正在发生的事情，并注意到我们的一项服务显示出非常高的 CPU 负载。这是不寻常的，因为我们的软件通常非常高效。在进一步调查中，我们注意到我们的新消息代码显然卡住了。这一定是达伦看到的。很明显，我们的新消息代码有问题！
我们立即做出了反应。我们告诉大家，候选版本可能还没有准备好发布。我们开始考虑我们可能不得不采取一个分支，这是我们通常试图避免的，并取消我们的消息更改。
我们在停下来思考之前做了所有这些。 “等等，这没有任何意义；我们已经运行这个代码一个多星期了，现在我们在几个小时内看到了 3 次失败。”
我们停下来讨论我们所知道的；我们收集了我们的事实。我们在迭代开始时升级了消息传递，我们有一个线程转储显示消息停止；达伦也是如此，但他的垃圾场看起来停在了不同的地方。一个多星期以来，我们一直在我们的部署管道中反复成功地运行所有这些测试，并且消息发生了变化。
在这一点上，我们被困住了。我们的假设，失败的消息传递，不符合事实。我们需要更多的事实，以便我们可以建立一个新的假设。我们再次开始，我们通常会开始解决问题，但这次因为结论看起来太明显而忽略了。我们描述了我们的问题，所以我们开始收集数据来讲述这个故事。我们查看了日志文件并发现，正如您可能已经猜到的那样，一个异常明确指向了一些全新的代码。
长话短说：消息传递很好。明显的“消息传递问题”是一种症状，而不是原因。我们实际上正在查看处于正常等待状态并按预期工作的线程转储。发生的事情是我们在一些与消息无关的新代码中遇到了线程错误。这是一个显而易见的简单修复，如果我们没有得出结论说这是一个消息传递问题，我们会在五分钟内毫不费力地找到它；事实上，一旦我们停下来思考并根据我们拥有的事实建立我们的假设，我们确实在五分钟内修复了它，而不是跳到一些错误但显然“明显”的结论。
只有当我们停下来列出我们所看到的事实时，我们才意识到我们所得出的结论确实不符合这些事实。正是这个和这个促使我们去收集更多的事实——足以解决我们遇到的问题，而不是我们想象的问题。
我们有一个复杂的自动化测试系统，但我们忽略了显而易见的事情。很明显，我们一定犯了一些破坏构建的事情。相反，我们将各种事实结合在一起并得出错误的结论，因为有一系列事件使我们走上了错误的道路。我们在沙子上建立了一个理论，不是一边验证一边验证，而是在旧的基础上建立新的猜测。它创造了一个最初似是而非的、看似“明显”的原因，但它完全是错误的。
科学有效！做一个假设。弄清楚如何证明或反驳它。进行实验。观察结果，看看它们是否符合你的假设。重复！
这里的教训是，经验主义比看起来更复杂，需要更多的纪律才能实现。你可以想象，当我们将 Darren 所看到的问题与失败的测试相关联时，我们是凭经验对现实向我们发送的信息做出反应。然而，我们不是。我们急于下结论并歪曲事实以符合我们对问题所在的首选猜测。如果那时我们只是以更有条理的方式浏览“我们所知道的”，这将是完全明显的，这不是“消息问题”，因为我们的消息更改整周都在起作用并且没有改变因为他们一直在工作。

## 避免自欺欺人
经验主义要求我们在如何组合从现实中收集到的信号并将它们组合成我们可以通过实验进行测试的理论方面更有条理。
人类是非凡的，但像我们一样聪明需要大量的处理。我们对现实的感知不是“现实”，我们有一系列生物学技巧可以让我们对现实的感知看起来是天衣无缝的。例如，我们的视觉采样率出奇地慢。通过你的眼睛收集的你对现实感知的平滑度是你的大脑创造的一种幻觉。实际上，您的眼睛会对视野中的一小块区域进行采样，大约每几秒钟扫描一次，您的大脑就会对真实情况产生“虚拟现实”印象。
您看到的大部分内容都是您的大脑做出的猜测。这很重要，因为我们已经进化到可以欺骗自己。我们现在急于下结论，因为如果我们在为生存而战的日子里花时间对我们的视野进行详细准确的分析，那么在我们完成之前我们就会被捕食者吃掉。
我们有各种各样的认知捷径和偏见，我们已经进化了数百万年，以使我们能够在现实世界中生存。然而，在我们创造的世界中，我们的现代高科技文明已经取代了捕食者居住的危险热带稀树草原，我们已经开发出一种更有效的方法来解决问题。它比跳出经常错误的结论要慢，但它在解决问题——有时甚至是极其困难的问题——方面要有效得多。理查德·费曼 (Richard Feynman) 对科学的著名描述如下：
第一个原则是你不能欺骗自己——你是最容易被欺骗的人。 3

科学并不是大多数人认为的那样。这与大型强子对撞机或现代医学甚至物理学无关。科学是一种解决问题的技术。我们为面前的问题创建一个模型，然后检查我们目前知道的所有内容是否都适合该模型。然后我们试着想办法证明模型是错误的。 David Deutsch 说该模型由“很好的解释”组成。4

## 创造一个符合我们论点的现实

让我们看另一个例子，说明我们是多么容易欺骗自己。
在我们构建超快速交易所的同时，5 我们对创建超快速软件进行了大量实验。我们通过实验发现了很多有趣的东西。最值得注意的是一种我们称之为机械同情的软件设计方法。
在这种方法中，我们基于对底层硬件如何工作的相当深入的理解来设计我们的代码，以便我们可以利用它。通过实验，我们学到的几个重要教训之一是，一旦您消除了愚蠢的错误6，对现代计算机中一段代码的原始性能的最显着影响就是缓存未命中。
避免缓存未命中成为我们设计代码中高性能部分的主要方法。
我们通过测量发现的大多数系统缓存未命中的最常见原因之一是并发。
当我们建立我们的交易所时，这是软件行业的一个普遍想法，当时公认的智慧是这样的：“硬件正在接近物理极限，这意味着 CPU 速度不再增加。因此，我们的设计必须‘并行’以保持良好的性能。”
有关于这个主题的学术论文和专门设计的语言，使并行编程在解决日常编程问题时更容易和更普遍。实际上，正如我们所展示的，这个模型有很多错误，但为了这个故事的目的，我将只看一个方面。当时正在讨论一种旨在自动并行化解决方案的学术语言。 7

3. 诺贝尔物理学奖获得者理查德·费曼（Richard Feynman，1918-1988），https://bit.ly/2PLfEU3

4. 无限的开始”，David Deutsch，https://amzn.to/2IyY553

5. 在此处阅读有关我们交易所创新架构的更多信息：https://bit.ly/3a48mS3。

6. 最常见的性能错误是使用错误的数据结构来存储东西。许多开发人员没有考虑检索不同类型集合的时间。

对于较小的集合大小，简单的数组（检索时为 O(n)）可能比哈希表（具有 O(1) 语义）更快。对于较大的集合，O(1) 解决方案最适合随机访问。之后，集合的实施可能会开始产生成本。

通过处理一本书的文本以从字符流中解析出单词，展示了这种语言的强大功能。鉴于我们的经验和我们对并发性的巨大成本的信念，至少当问题要求我们将来自不同并发执行线程的结果组合起来时，我们持怀疑态度。
我们无法使用学术语言，但我的一位同事 Mike Barker 做了一个简单的实验。他实现了语言学者在 Scala 中描述的相同算法，在 Java 中实现了一种简单的蛮力方法，然后通过一系列运行处理刘易斯卡罗尔的爱丽丝梦游仙境的文本来测量结果。
并发Scala算法用61行代码实现； Java 版本需要 33。Scala 版本每秒可以处理令人印象深刻的 400 本书副本。这令人印象深刻，直到您将其与 Java 中更简单、更易于阅读的单线程代码进行比较，每秒可处理 1,600 个副本。
语言研究人员从一个理论开始——并行性就是答案——但他们太沉迷于一个实现，以至于他们从未想过测试他们的起始前提，即这会导致更快的结果。这导致了更慢的结果和更复杂的代码。

> 将神话与现实分开：示例
>
> 据了解，CPU 的发展已达到极限，不断增加的时钟周期加速已经暂停。自 2005 年左右以来，时钟周期没有增加！基于用硅制造晶体管的物理原理，这是有充分理由的。晶体管的密度与它们在操作中产生的热量之间存在关系。构建速度远高于 3GHz 的芯片意味着过热会成为一个严重的问题。
> 因此，如果我们不能通过提高 CPU 中线性处理指令的速率来获得速度提升，我们可以并行化，而处理器制造商有。这很好：现代处理器是了不起的设备，但我们如何使用所有这些功能？我们可以并行工作！
> 这对于运行未连接的独立进程很好，但是如果您想构建一个快速算法怎么办？显而易见的结论（猜测）是，这个问题的解决方案是并行化我们的算法是不可避免的。本质上，这里的想法是我们可以通过在我们解决的问题上投入更多的执行线程来加快速度。
> 有几种通用编程语言建立在这个假设之上，以帮助我们更有效地编写并行解决方案。
> 7. 自动并行化概述：https://bit.ly/35JPqVs
>
> 不幸的是，这是一个比看起来更复杂的问题。对于一些不寻常的任务，并行执行就是答案。但是，一旦需要将来自这些不同执行线程的信息重新组合在一起，情况就会发生变化。
> 让我们收集一些反馈。让我们收集一些数据，而不是直接得出并行化事物就是答案的结论。
> 我们可以尝试一些简单的事情。例如，让我们编写一个简单的算法来将一个简单的整数递增 5 亿次。
> 没有任何反馈，很明显我们可以在这个问题上抛出很多线程。但是，当您进行此实验并收集数据（反馈）时，结果可能会让您大吃一惊：
>
> | 方法                | 时间（毫秒） |
> | ------------------- | ------------ |
> | 单线程              | 300          |
> | 带锁的单线程        | 10,000       |
> | 带锁的两个线程      | 224,000      |
> | 带CAS的单线程       | 5,700        |
> | 两个带有 CAS 的线程 | 30,000       |
>
> 上表显示了使用不同方法进行的该实验的结果。首先，基线测试。在单个线程上编写代码并增加一个 long 值。达到 5 亿需要 300 毫秒。
> 一旦我们引入了同步事物的代码，我们就会开始看到一些我们没有预料到的成本（除非我们是低级并发专家）。如果我们仍然在单个线程上完成所有工作，但添加一个锁以允许从不同线程使用结果，则会增加 9,700 毫秒的成本。锁非常贵！
> 如果我们决定只在两个线程之间分配工作并同步它们的结果，它比在单个线程上工作慢 746 倍！
> 所以锁是非常昂贵的。有更难使用但更有效的方法来协调线程之间的工作。执行此操作的最有效方法是称为比较和交换 (CAS) 的低级并发方法。可悲的是，即使是这种方法也比在单线程上工作慢 100 倍。
> 根据这些反馈，我们可以做出更明智的、基于证据的决策。如果我们想最大化算法取得进展的速度，我们应该尝试在单个线程上保持尽可能多的工作，除非我们可以取得进展并且永远不会再将结果重新组合在一起。
> （这个实验最初是由迈克·巴克（Mike Barker）在我们几年前一起工作时进行的。）

前面边栏中的示例演示了本书核心的几个概念。它展示了反馈、实验和经验主义的重要性。
以现实为导向
在这种情况下，研究人员本着良好的意图行事，但他们陷入了科学和工程领域之外普遍存在的陷阱：他们提出了解决问题的猜测，然后急于实施他们的猜测没有先检查他们的猜测是对还是错。
Mike 使用研究人员自己的示例问题进行了几个小时的编码，以证明他们假设的解决方案没有意义。持怀疑态度并检查我们的想法是工作，但这是取得真正进步的唯一途径，而不是继续猜测、假设和狂妄自大。
最好的开始方法是假设您所知道的和您的想法可能是错误的，然后找出如何找出错误的方法。
这个故事中的编程语言学者相信了一个没有现实基础的神话。他们已经建立了并行化编程语言的模型，因为如果你是一名语言学者，这是一个很酷的问题。
不幸的是，这并没有考虑到并行性的成本；他们忽视了现代计算机硬件和计算机科学的现实。人们早就知道，当您需要“将结果重新组合在一起”时，并行会产生成本。 Amdahl 定律表明，有意义的并发操作数量存在严格限制，除非它们完全相互独立。
学者们假设“更多的并行性是好的”，但这是一个基于某种想象的理论机器的想法，其中并发成本很低；这样的机器不存在。
这些学者虽然是实验性的，但并不是经验性的。缺乏经验主义意味着他们的实验是错误的实验，因此他们建立的模型与现实世界的经验不符。
经验主义是一种机制，通过它我们可以感觉检查我们的实验的有效性。它帮助我们将它们置于上下文中，并且实际上是在我们实验的核心测试现实模拟的有效性。

## 概括

工程而不是纯科学要求我们对解决方案的实用性进行一些考虑。这就是经验主义真正发挥作用的地方。仅仅看世界，根据我们所看到的进行猜测，然后假设我们的猜测一定是正确的，因为我们从现实世界中获得了告知他们的信息，这是不够的。那是糟糕的科学和糟糕的工程。然而，工程学是一门实践学科。因此，我们必须不断地对我们的猜测以及我们为测试它们而创建的实验持怀疑态度，并将它们与我们的现实经验进行比较。


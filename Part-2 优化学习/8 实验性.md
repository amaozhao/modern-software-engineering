实验被定义为“为支持、反驳或验证假设而进行的程序。实验通过展示操纵特定因素时会发生什么结果，从而深入了解因果关系。”1
采取实验方法来解决问题非常重要。我认为科学及其核心的实验实践是我们现代高科技社会与我们之前的农业社会的区别，最重要的是。人类作为一个独特的物种已经存在了数十万年，但自牛顿或伽利略以来，我们在过去 300 或 400 年中取得的进步速度，大多数人将其标记为现代科学的开端，已经超过了以前的所有东西许多数量级。据估计，在我们的文明中，整个人类知识每 13 个月就会翻一番。 2
这在很大程度上是因为应用了人类最好的解决问题的技术。
然而，大多数软件开发实际上并不是这样工作的。大多数软件开发都是有意识地作为一种技巧练习来进行的，有人猜测用户可能喜欢什么。他们猜测可以实现其产品目标的设计和/或技术。开发人员然后猜测他们编写的代码是否符合他们的意思，并且他们猜测其中是否有任何错误。许多组织都在猜测他们的软件是否有用，或者赚的钱是否比构建它的成本更高。
我们可以做得更好。我们可以在合适的地方使用猜测，然后我们可以设计实验来测试猜测。
1. 来源：维基百科，https://en.wikipedia.org/wiki/Experiment

2. Buckminster Fuller 创建了知识倍增曲线：https://bit.ly/2WiyUbE。

这听起来缓慢、昂贵且复杂，但事实并非如此。这实际上只是方法和思维方式的转变。这不是“更努力地工作”；这是关于“更聪明地工作”。我所见过的以这种方式工作并将这些想法铭记于心的团队并不慢或过于学术。然而，他们在解决问题的方式上更加自律，因此，他们能够更快地找到更好、更便宜的解决方案，并生产出质量更高、更令用户满意的软件。

## “实验性”是什么意思？
作为科学思维根源的关键思想之一是摆脱权威做出的决定。理查德·费曼 (Richard Feynman) 一如既往地引用了这个话题：
科学是相信专家的无知。

他还说：
丝毫不尊重权威；忘记是谁说的，而是看看他从什么开始，到哪里结束，然后问问自己，“这合理吗？”

尽管他那个时代的语言有些性别歧视，但这种情绪是正确的。
我们必须摆脱根据最重要、最有魅力或最着名的人所说的话做出决定，即使是理查德·费曼 (Richard Feynman)，而是根据证据做出决定和选择。
这对我们的行业来说是一个巨大的变化，而不是它通常的运作方式。可悲的是，整个社会也是如此，而不仅仅是软件开发，所以如果我们作为工程师要取得成功，我们必须比整个社会做得更好。
是什么让您选择使用的编程语言、框架或编写代码的编辑器？您是否在对话中争论 Java 与 Python 的相对优点？您认为使用 VI 作为编辑器的每个人是聪明还是傻瓜？你认为函数式编程是一种真正的方式，还是你认为面向对象是有史以来最好的发明？我也是！
我并不是为每一个这样的决定都建议我们应该创建一个详尽的、受控的实验，但我们应该停止对这些事情进行宗教战争。
如果我们要论证 Clojure 比 C# 更好，为什么不做一点试验并衡量结果的稳定性和吞吐量？至少我们可以根据一些证据做出决定，即使不是完美的，而不是根据谁在论证中最有说服力来做出这样的决定。如果您不同意结果，请进行更好的实验并展示您的推理。
实验并不意味着每一个决定都基于硬物理学。所有的科学都建立在实验的基础上，但控制的程度各不相同。在工程学中，实验仍然是其核心，但它是一种务实、实用的实验形式。
四个特征将“实验性”定义为一种方法：

- 反馈：我们需要认真对待反馈，我们需要了解我们将如何收集结果，这些结果将为我们提供清晰的信号，并有效地将它们返回到我们思考的点。我们需要关闭循环。
- 假设：我们需要有一个想法，我们的目标是评估。我们不会随意地四处游荡，随机收集数据。这还不够好。
- 测量：我们需要清楚地了解如何评估我们在假设中测试的预测。在这种情况下，“成功”或“失败”是什么意思？
- 控制变量：我们需要尽可能多地消除变量，以便我们能够理解我们的实验发送给我们的信号。

## 反馈

从工程的角度来看，重要的是要认识到加快反馈的效率和质量可以带来的影响。

> **对速度的要求**
>
> 我曾经在一家生产复杂的金融交易软件的公司工作。开发人员非常优秀，公司也很成功，但他们仍然知道自己可以做得更好，而我的工作就是帮助改进他们的软件开发实践。
> 当我加入时，他们采用了一种相当有效的自动化测试方法。他们进行了很多测试。他们运行了一个通宵构建，他们提供的大部分产品包括一个大型 C++ 构建，需要九个半小时才能完成，包括运行所有测试。所以他们每晚都运行构建。
> 其中一位开发人员告诉我，他们以这种方式工作的三年中，只有 3 次所有测试都通过了。
> 因此，每天早上他们都会挑选所有测试都通过的模块并发布它们，同时阻止产生测试失败的模块。
> 这很好，只要传递的模块之一不依赖于失败模块之一的更改，有时他们会这样做。
> 我想改变很多东西，但作为第一步，我们努力提高反馈的效率，没有其他变化。
> 经过大量的实验和努力，我们设法获得了一个快速阶段，提交构建在 12 分钟内运行，其余测试在 40 分钟内运行。这与九个半小时的构建工作相同，只是速度更快！除了加快构建速度并更有效地将结果提供给开发人员之外，组织、流程或工具没有其他变化。
> 在此更改发布后的前两周内，有两个版本通过了所有测试。在那之后的两周内，只要我在那里工作，每天至少有一次构建，所有测试都通过了，所有代码都可以发布。
> 除了提高反馈速度外，没有其他改变为团队提供了解决潜在不稳定性所需的工具。

“极品飞车”中的“战争故事”很好地证明了将实验技术应用于我们的工作以及优化以获得良好反馈的有效性。在这种情况下，我们尝试提高向开发人员反馈的效率和质量。在这项工作的过程中，我们建立了更好的构建性能度量，通过改进的版本控制和基础设施即代码来控制变量，并且 A/B 测试了几种不同的技术解决方案和构建系统。
只有通过采取一种相当有纪律的方法将这种实验思维应用于这个问题——以前各种尝试都试图改进的问题——我们才能够取得进展。我们的一些想法没有成功。我们的实验表明，在某些工具或技术上投入大量时间和精力是没有好处的，因为它们不会为我们提供所需的加速。

## 假设

在谈论科学和工程时，人们经常谈论“消除猜测”。我也为过去使用这句话而感到内疚。然而，这是错误的。在一个重要的意义上，科学建立在猜测之上；只是解决问题的科学方法将猜测制度化并称之为假设。正如理查德·费曼 (Richard Feynman) 在他关于科学方法的精彩演讲中雄辩地指出的那样：
我们通过以下过程寻找新的规律，首先我们猜吧！

猜测或假设是起点。与其他不太有效的方法相比，科学和工程之间的区别在于其他方法止步于此。
科学地说，一旦我们以假设的形式进行了猜测，我们就开始做出一些预测，然后我们可以尝试找到验证这些预测的方法。
3. 诺贝尔物理学奖获得者理查德·费曼关于科学方法：https://bit.ly/2RiEivq

费曼在那个伟大的演讲中继续说：
如果你的猜测与实验不一致，那么它（你的猜测）是错误的！

这就是它的心脏！这就是我们需要到达的地方，以便能够声称我们所做的是工程而不是猜测。
我们需要能够检验我们的假设。我们的测试可以采用多种形式。我们可以观察现实（生产），或者我们可以进行一些更可控的实验，也许以某种自动化测试的形式。
我们可以专注于从生产中获得良好的反馈来为我们的学习提供信息，或者我们可以在更可控的环境中尝试我们的想法。
组织我们的思考和我们的工作，作为一系列实验来验证我们的假设，这是我们工作质量的重要改进。

## 测量
无论我们是收集数据以从现实（生产）中进行解释，还是进行更可控的实验，我们都需要认真对待测量。我们需要考虑我们收集的数据意味着什么，并对它持批评态度。
通过试图“将事实与数据相匹配”来欺骗自己太容易了。作为实验设计的一部分，我们可以通过仔细思考我们认为有意义的测量来避免此类错误。我们需要根据我们的假设做出预测，然后弄清楚如何衡量我们的预测结果。
我能想到很多衡量错误事物的例子。在我的一个客户那里，他们决定可以通过提高测试覆盖率来提高代码质量。因此，他们开始了一个项目来进行测量，收集数据，并采取了鼓励提高测试覆盖率的政策。他们设定了“80% 的测试覆盖率”的目标。然后他们使用该度量来激励他们的开发团队，奖金与达到测试覆盖率的目标相关联。
你猜怎么着？他们的目的达到了！
一段时间后，他们分析了他们拥有的测试，发现超过 25% 的测试根本没有断言。因此，他们通过奖金支付给开发团队的人员，让他们编写根本不测试任何内容的测试。
在这种情况下，更好的衡量标准是稳定性。该组织真正想要的不是更多的测试，而是更高质量的代码，因此更直接地衡量它的效果更好。
这种衡量错误事物的困难不仅适用于“指标”和人类在玩弄系统时的聪明才智。
我在低延迟金融系统中工作了十多年。刚开始时，我们非常专注于测量延迟和吞吐量，因此我们努力捕捉测量结果，为自己设定了“系统应该能够每秒处理 100,000 条消息且延迟不超过 2 毫秒”这样的目标。我们的第一次尝试是基于平均值，后来我们发现这是毫无意义的。我们需要更具体；在随后的交易周期中，有时我们的峰值负载远远超过 100,000 msg/sec 的等效速率，峰值数量相当于数百万 msg/sec。如果存在超出特定限制的异常值，则平均延迟并不重要。在高频交易的现实世界中，2ms 不是平均值——那是极限！
在第二个示例中，我们开始进行实验，但是，部分由于我们测量的准确性，即使我们测量了一些错误的东西，我们很快开始学习并提高我们测量的质量和准确性，并更好地针对我们的实验。一切都是为了学习！
并不是每个人都在意这种测量精度，但无论您正在构建何种类型的软件，原则都是一样的。实验要求我们更加关注系统的测量，无论这在我们的上下文中意味着什么。

## 控制变量
为了收集反馈并进行有用的测量，我们需要尽可能地控制变量。当 Jez Humble 和我写我们的书持续交付时，我们将其副标题为通过构建、测试和部署自动化实现可靠的软件发布。我不认为我当时是这样想的，但这真正说的是“控制变量，使您的发布可靠”。
版本控制使我们能够更精确地了解我们发布到生产中的更改。自动化测试使我们能够更精确地了解我们生产的软件的行为、速度、稳健性和总体质量。部署自动化和基础设施即代码等想法使我们能够更准确地了解我们的软件运行的环境。
所有这些技术都让我们更加确信，当我们将软件投入生产时，它会按照我们的意愿行事。
我认为持续交付是一种通用的软件开发方法，它使我们能够更有把握地进行。它在很大程度上消除了围绕我们工作质量的变量，以便我们可以专注于我们的产品创意是否好。我们可以更清楚地了解“我们是否在做正确的事情”，因为我们已经控制了“我们在做正确的事情”。
通过控制软件开发中的许多技术变量，持续交付使我们能够比以前更有信心地取得进展。这使得软件开发团队能够真正利用作为本书核心的学习优化技术。
例如，持续交付部署管道是一个理想的实验平台，用于了解我们希望对生产系统进行的更改。
为了让我们的软件始终处于可发布状态，CD 的核心理念是最大限度地提高我们对工作质量的反馈，并强烈鼓励我们以更小的步骤工作。反过来，这意味着我们几乎被迫迭代和增量地工作。
拥有始终处于可发布状态的软件，我们不利用它是愚蠢的！这意味着组织可以更频繁地发布并收集更多关于其想法质量的反馈，并更快地构建更好的产品。

## 作为实验的自动化测试
实验可以有多种形式，但在软件方面，我们比其他任何学科都有巨大的优势，因为我们拥有这个奇妙的实验平台：计算机！
如果我们愿意，我们可以每秒运行数百万次实验。这些实验也可能采取各种不同的形式；我们可以将编译步骤视为一种实验形式：“我预测我的代码将在没有任何警告的情况下编译”或“我预测我的 UI 代码都不会访问数据库库”。然而，到目前为止，在软件环境中，最灵活的实验形式是自动化测试。
如果您足够努力，任何验证我们软件的自动化测试都可以被视为实验。但是，如果在编写代码之后编写自动化测试，则实验的价值就会降低。实验应该基于某种假设，而决定您的代码是否有效是一个非常蹩脚的假设。
我在想的是围绕一系列迭代实验来组织我们的开发，这些实验对我们的代码的预期行为做出微小的预测，这将使我们能够逐步增加我们软件的功能。
这种实验最清晰的形式是由测试或测试驱动开发 (TDD) 引导的软件开发。
TDD 是一种有效的策略，我们将测试用作系统行为的可执行规范。准确定义我们要实现的行为改变是我们的假设：“鉴于这种特定的背景，当这件事发生时，我们就会期待这个结果。”我们以一个小的、简单的测试的形式创建这个预测，然后在我们完成代码并进行实验时确认我们的测试用例的预测得到满足。
我们可以在不同的粒度级别上运行这种 TDD 方法。我们可以从创建以用户为中心的规范开始，使用验收测试驱动开发 (ATDD) 技术，有时也称为行为驱动开发 (BDD)。我们使用这些高级别的可执行规范来指导更细粒度、更具技术性的单元测试。
与传统开发的软件相比，使用这些技术开发的软件的错误显着减少。 4
这是一个受欢迎的质量改进，但在我们还考虑到这种减少对生产力的影响之前，我们并没有真正看到它的价值。据推测，由于缺陷的减少，开发团队在其他活动上花费的时间显着减少，例如错误检测、分类和分析。
结果是，采用 TDD、持续集成和持续交付等技术的高绩效团队在有用工作上花费的时间增加了 44%。5 这些团队的工作效率比正常团队高得多，同时，产生了更高质量结果。你可以拥有你的蛋糕并吃掉它！
持续交付背景下的极限编程实践，特别是持续集成和 TDD，提供了一个美妙的、可扩展的、实验性的平台，我们可以在其中评估和完善我们在设计和实现方面的想法。这些技术对我们的工作质量和我们生产优秀软件的速度有着重要的影响。在其他学科中，我们会将这些结果归因于工程学。

## 将测试的实验结果置于上下文中
原谅我有点哲学，但我希望你现在已经习惯了。
让我们想想像我刚刚描述的那些测试，真正意味着什么。
我主张将科学合理性作为我试图在这里描述的方法的指导原则。软件开发人员（或许是一般人）的一个常见错误是，一提到“科学”，我们几乎总是想到“物理学”。
我是一个业余物理书呆子。我喜欢物理学和它允许我构建的心理模型来理解我周围的事物。我有时会开玩笑说物理学是一门真正的科学，但我不是那个意思。
科学比物理学更广泛，但在我们用作物理学核心的简化抽象领域之外，其他科学通常更加混乱和不那么精确。这并没有降低科学式推理的价值。生物学、化学、心理学和社会学也是科学。它们无法像物理学那样准确地做出预测，因为它们无法在实验中严格控制变量，但它们仍然提供比替代方案更深入的洞察力和更好的结果。我一刻也不期望我们像物理学一样彻底或精确。
4. 有几项关于 TDD 对减少缺陷的影响的学术和非正式研究。大多数研究都同意缺陷减少的范围从 40% 到远远超过 250%。资料来源：https://bit.ly/2LFixzS、https://bit.ly/2LDh3q3、https://bit.ly/3cLT5F0

5. 来源：“DevOps 状态”报告（不同年份）和 Accelerate：Fosgren、Humble 和 Kim 撰写的精益和 DevOps 科学。请参阅 https://amzn.to/369r73m。

尽管如此，在软件方面，我们比几乎所有其他形式的工程和几门科学都有一些深刻的优势，在这些科学中，由于道德或实践原因，实验通常很困难。我们可以完全创建和控制我们的软件所在的“宇宙”。如果我们选择这样做，我们可以进行微妙、精确的控制。我们可以以低成本创建数百万次实验，从而使我们能够利用统计的力量来发挥我们的优势。简单地说，这就是现代机器学习的真正含义。
计算机让我们有机会控制我们的软件并对其进行实验，其规模在任何其他环境中都是无法想象的。
最后，软件赋予我们的还有一种非常深刻的能力。
所以我们不会成为物理学家，但让我们想象一下我们是。如果你和我在物理学中提出了一个新想法，我们怎么知道它是否是一个好想法？好吧，我们需要充分阅读以了解它符合物理学目前所理解的事实。如果我们不知道爱因斯坦说了什么，那么暗示“爱因斯坦错了”是没有用的。物理学是一门广阔的学科，所以无论我们读得多么好，我们都需要足够清楚地描述这个想法，以便其他人可以复制它，以便他们也可以对其进行测试。如果这个想法的任何测试失败，在检查它不是测试中的错误之后，我们可以拒绝这个想法。
在软件中，我们可以通过测试来完成所有这些，而不是我们的想法需要数月或数年才能开花结果，我们可以在几分钟内得到结果。这就是我们的超能力！
如果我们认为我们的软件存在于我们创建的一个小宇宙中，无论软件有多大或多复杂，那么我们都可以精确地控制这个宇宙并评估我们的软件在其中的作用。如果我们努力能够“控制变量”到我们可以可靠且可重复地重新创建该领域的程度——例如，作为持续交付部署管道一部分的基础设施即代码——那么我们就有了一个很好的起点对于我们的实验。
我们编写的所有测试的完整集合，包括断言我们对系统在受控宇宙中的行为的理解的实验集合，是我们对系统的知识体系。
我们可以将“宇宙”和“知识体系”的定义提供给任何人，他们可以确认它们作为一个整体在内部是一致的——测试全部通过。
如果我们想在系统中“创造新知识”，我们可以创建一个新的实验，一个测试，定义我们期望观察到的新知识，然后我们可以以符合以下要求的工作代码的形式添加这些知识实验的需要。如果新想法与以前的想法不一致，即我们迷你受控宇宙中的“知识体系”，那么实验就会失败，我们就会知道这个想法是错误的，或者至少与记录的陈述不一致。系统中的知识。
现在，我认识到这是一个软件系统及其相关测试的理想化表示，但我已经在几个非常接近这个理想的系统上工作过。然而，即使你只完成了 80%，想想这意味着什么。在几分钟内，您就可以在系统范围内了解您的想法的有效性和一致性。
正如我之前所说，这是我们的超能力。如果我们将软件视为一个工程过程，而不是仅基于工艺的过程，那么这就是我们可以用软件做的事情。

## 实验范围
实验有各种规模。我们可以做一些微小的、几乎微不足道的事情，或者我们可以做一些大而复杂的事情。有时我们需要这两样东西，但“在一系列实验中工作”的想法对某些人来说听起来令人生畏。
让我描述一种我在自己的软件开发中经常进行的常见实验，让您放心。
在实践 TDD 时，我通过测试开始对我的代码进行预期的更改。目的是创建一个失败的测试。我们想运行测试并看到它无法检查测试是否真的在测试某些东西。所以我从编写测试开始。一旦我按照我的意愿进行了测试，我将预测我希望测试失败的确切错误消息：“我希望此测试失败并显示一条消息‘预期为 x 但为 0’”或类似的信息。这是一个实验；这是科学方法的一个微小应用。
我思考并描述了这个问题：“我已经决定了我想要的系统行为，并将其捕获为测试用例。”

我形成了一个假设：“我希望我的测试失败！”

我做了一个预测：“当它失败时，它会失败并显示此错误消息......”

我进行了实验：“我进行了测试。”

与我之前的工作方式相比，这是一个微小的变化，但它对我的工作质量产生了重大的积极影响。
在我们的工作中应用更有纪律的实验方法不需要复杂或繁重。如果我们要成为软件工程师，我们需要采用这样的学科，并将它们始终如一地应用到我们的工作中。

## 概括

以更具实验性的方式工作的一个关键属性是我们对所涉及的变量施加控制的程度。本章开头对“实验”的部分定义是“演示当特定因素被操纵时会发生什么”。为了更具实验性地工作，我们需要对我们的工作方法进行更多的控制。我们希望我们“实验”的结果是可靠的。在我们构建的系统的技术环境中，通过有效的自动化测试和持续交付技术（如基础设施即代码），实验性地工作并控制我们可以控制的变量，使我们的实验更加可靠和可重复。但更深刻的是，它们也使我们的软件更具确定性，因此在使用中质量更高、更可预测且更可靠。
任何名副其实的软件工程方法都必须为相同的工作量产生更好的软件。将我们的工作组织成一系列通常很简单的小实验就可以做到这一点。
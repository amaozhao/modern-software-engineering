反馈被定义为“将有关行动、事件或过程的评估或纠正信息传输到原始或控制源。”1
没有反馈，就没有学习的机会。我们只能猜测，而不是根据现实做出决定。尽管如此，令人惊讶的是，许多人和组织对它的关注很少。
例如，许多组织为新软件创建了一个“商业案例”。这些组织中有多少继续跟踪开发成本并对其进行评估，以及交付给客户的实际收益，以验证他们的“业务案例”是否得到满足？
除非我们能够知道和理解我们的选择和行动的结果，否则我们无法判断我们是否正在取得进展。
这似乎很明显，不值得一提，但在实践中，猜测、等级制度和传统是大多数组织中更广泛使用的决策仲裁者。
反馈使我们能够为我们的决定建立证据来源。一旦我们有了这样的来源，我们的决策质量就会不可避免地得到改善。它让我们开始将神话与现实分开。
1. 资料来源：韦氏词典。 https://www.merriam-webster.com/dictionary/feedback

## 反馈重要性的实际例子

理解抽象的想法可能很困难。让我们想象一个简单实用的例子，说明速度和质量在反馈中的重要性。
想象一下正面临平衡扫帚的问题。
我们可以决定仔细分析扫帚的结构，计算出它的重心，仔细检查手柄的结构，并精确计算扫帚完美平衡的点。然后我们可以非常小心地将扫帚操纵到我们计划的精确位置，并通过完美的执行，确保我们没有留下任何使扫帚加速失去平衡的残余冲动。
第一种方法类似于瀑布开发模型。可以想象它会起作用，但难以置信地不可能。结果极不稳定。它依赖于我们的预测是完美的，并且考虑到我们预测的最小扰动或不准确，扫帚会落下。
或者，我们可以将扫帚放在手上并根据它的倾斜方式移动我们的手。
第二种方法是基于反馈。设置速度更快，反馈的速度和质量将推动其成功。如果我们的手移动太慢，我们将不得不进行大的修正。如果我们感觉扫帚倾斜的方向太慢，我们将不得不进行大的修正，否则扫帚就会掉下来。如果我们的反馈快速有效，我们可以进行微小的修正，扫帚就会稳定。事实上，即使有什么事情出现并打扰了扫帚或我们，我们也可以迅速做出反应并纠正问题。
第二种方法非常成功，这就是太空火箭在发动机推力上“平衡”的方式。稳如泰山，只要我擅长，就算你不小心推了我一脚，我也能保持平衡。
第二种方法感觉更临时；从某种意义上说，它感觉不那么严格，但它更有效。
我可以想象你此时会想，“我们的作者喝了什么？扫帚和软件有什么关系？”我的观点是，关于流程的工作方式有一些深刻而重要的东西。
第一个例子是有计划的、预测性的方法。只要您完全理解所有变量并且没有任何事情改变您的理解或您的计划，这种方法就会很好地工作。这确实是任何详细、有计划的方法的基础。如果你有一个详细的计划，那么只有一个正确的解决方案，所以要么问题必须非常简单才能使之成为可能，要么你必须无所不知地预测未来。
第二种替代方法仍然涉及“我要平衡扫帚”的计划，但该计划完全是关于结果的，而没有说明实现目标的机制。相反，您只需开始工作并尽一切努力实现所需的结果。如果这意味着响应反馈并非常快速地移动你的手几毫米，那很好。如果这意味着由于意外发生而将手移动一米或更多的同时向前和向侧面迈出惊人的几步，那也没关系，只要能实现结果即可。
第二种方法虽然看起来更临时，更像是“随心所欲”，但实际上在结果方面更有效、更稳定。在第一种方法中，只有一个正确的解决方案。在第二个中有很多，所以我们更有可能实现其中一个。
反馈是在不断变化的环境中运行的任何系统的重要组成部分。软件开发始终是一种学习的练习，它发生的环境总是在变化；因此，反馈是任何有效软件开发过程的重要方面。

> 北约会议2
>
> 到 1960 年代后期，很明显计算机编程是一件很难做好的事情。正在构建的系统在规模、复杂性和重要性方面都在增加。为它们编程的人数正在迅速增长。随着人们逐渐意识到难度的增加，他们开始思考他们可以做些什么来使创建软件的过程更高效、更不容易出错。
> 这种想法的一个结果是召开了一次著名的会议，试图定义软件工程是什么。该会议于 1968 年举行，旨在从广义上探索软件工程的意义和实践。
> 该会议是一个“仅限邀请”的活动，招募当时该领域的全球专家，在软件工程的背景下讨论广泛的想法。鉴于过去 50 年计算机硬件容量的显着增长，不可避免地会出现一些非常过时的想法：
> H J Helms 博士：仅在欧洲，就安装了大约 10,000 台计算机——这个数字正以每年 25% 到 50% 的速度增长。为这些计算机提供的软件质量很快将影响超过 100 万分析师和程序员中的四分之一。
>
> 其他想法似乎更持久：
> A J Perlis：Selig 的图片需要一个反馈回路，用于监控系统。必须收集有关系统性能的数据，以用于未来的改进。
>
> 虽然 Perlis 的语言听起来有些陈旧，但它的想法可能是描述一种现代 DevOps 开发方法，而不是用 Algol 编写的东西！2
> 2. 资料来源：“1968 年北约软件工程会议”，https://bit.ly/2rOtYvM
>
> 许多其他贡献也同样具有先见之明：
> F Selig：任何级别的外部规范，根据用户控制和可用的项目来描述软件产品。内部设计根据实现外部规范的程序结构来描述软件产品。必须理解，外部和内部规范设计之间的反馈是现实和有效实施过程的重要组成部分。
>
> 这种描述听起来非常像现代人耳熟能详的敏捷开发故事3，描述了在需求过程中将“什么”与“如何”分开的重要性。
> 有一些普遍真理的核心，凭借 21 世纪的后见之明，我们认识到我们贸易的问题和实践：
> d’Agapeyeff：编程仍然是一种艺术性的努力。我们需要一个更实质性的基础来在实践中进行教学和监督：
>
> (i) 程序的结构及其执行流程；
>
> (ii) 模块的形成和测试环境；
>
> (iii) 运行时条件的模拟。
>
> 有了这种后见之明，“塑造模块和环境[以促进]测试”和“模拟运行时条件”之类的想法听起来完全现代和正确，并且构成了软件开发持续交付方法的大部分基础。
> 今天阅读这些收益，有许多想法显然是持久的。它们经受住了时间的考验，今天和 1968 年一样真实。
> 与“使用语言 X”或“用图表技术 Y 证明你的设计”相比，“建立反馈循环”或“假设你会弄错”有一些不同的东西，一些更深刻的东西。

## 编码反馈
在实践中，这种对快速、高质量反馈的需求如何影响我们的工作方式？
如果我们认真对待反馈，我们需要很多反馈。编写代码并依靠测试团队在六周后报告它是不够的。
在我的职业生涯中，我自己编写代码的方法发生了重大变化。我现在一直在多个层面使用反馈。我以微小的步骤进行更改。
3. 用户故事是系统功能的非正式描述，从系统用户的角度编写。这是极限编程中引入的思想之一。

我通常采用测试驱动的方法来编写代码。如果我想向我的系统添加一些新行为，我将首先编写一个测试。
当我开始编写测试时，我想知道我的测试是否正确。我想要一些反馈来表明我的测试的正确性。所以我编写测试并运行它以查看它是否失败。失败的性质给了我反馈，帮助我了解我的测试是否正确。
如果测试通过，在我编写任何代码使其通过之前，我的测试有问题，我需要在继续之前更正它。所有这些都描述了专注于快速学习的细粒度反馈技术的应用。
正如我在前一章中所描述的，我通过一系列微小的步骤对代码进行了更改。这里至少有两个级别的反馈在起作用。例如，我经常使用 IDE 中的重构工具来帮助我完成第一个步骤，但我也会在每一步获得关于我的代码是否正常工作的反馈，更主观地说，如果我喜欢我在设计发展过程中看到的东西。结果，我发现错误或失误的能力大大增强。
每次我进行更改时，我都可以重新运行我当前正在使用的测试，从而提供了第二级反馈。这让我非常快速地确认我的代码在更改后继续工作。
这些反馈周期非常短，或者应该非常短。我在这里提到的大多数反馈周期最多只需要几秒钟。有些，比如运行你的单元测试来验证一切仍然有效，更有可能以毫秒为单位。
这个简短、快速的反馈周期非常有价值，因为它的速度和与您正在处理的工作相关的即时性。
将我们的工作组织成一系列微小的步骤，让我们有更多机会反思我们的进展并引导我们的设计朝着更好的结果发展。

## 集成反馈
当我提交代码时，它会触发我的持续集成系统并在其他人的上下文中评估我的更改。在这一点上，我得到了一个新的反馈水平。我有了更深的理解。在这种情况下，我现在可以了解代码中的某些内容是否“泄露”并导致系统的其他部分出现故障。
如果在此阶段所有测试都通过，我会收到反馈，表明我可以安全地继续处理下一件事。
这是支持持续集成理念的极其重要的反馈级别。
可悲的是，持续集成仍然被广泛误解和缺乏实践。如果我们试图建立一种严格的软件开发方法，那么工程方法对于冷静地评估想法的利弊很重要。这对我们的行业来说似乎常常是困难的。许多想法被广泛采用是因为它们感觉更好，而不是因为它们更好。
一个很好的例子是持续集成 (CI) 和特征分支 (FB) 实践者之间的争论。
让我们理性地分辨这些方法的优缺点。
持续集成是关于尽可能频繁地评估系统的每一个变化以及系统的每一个其他变化，尽可能接近“连续”我们实际上可以得到。
CI 的定义指出：
(CI) 是将所有开发人员的工作副本每天多次合并到共享主线的做法。 4

大多数 CI 专家会将“每天几次”放松到“每天至少一次”，这是一种可接受但不可取的妥协方案。
因此，根据定义，CI 是关于每天至少一次以小增量的方式将更改暴露给评估。
任何类型的分支，也根据定义，是关于隔离变化：
分支允许贡献者隔离更改。 5

在基本的定义术语中，CI 和 FB 并不真正相互兼容。一个目标是尽早暴露变化；另一个工作是推迟暴露。
FB 看起来很简单，它的从业者喜欢它，因为它似乎让生活更简单。 “我可以独立于我的队友进行编码。”问题出现在合并更改的时候。发明 CI 是为了解决“合并地狱”的问题。
在糟糕的过去，以及直到今天，在一些顽固的组织中，团队和个人会处理代码部分，直到它们被认为“完整”，然后再将它们合并为整体。
发生的事情是，此时发现了各种意想不到的问题，因此合并变得复杂，并且需要很长且不可预测的时间才能完成。
采取了两种方法来试图解决这个问题； CI就是其中之一。另一种方法是提高合并工具的质量。
FB 从业者的一个共同论点是，合并工具现在非常好，合并很少成为问题。然而，总是有可能编写出合并工具会遗漏的代码；合并代码不一定与合并行为相同。
假设你和我在同一个代码库中工作，我们有一个函数可以做几件事来转换一个值。我们都独立地决定这个函数需要将值加一，但是我们每个人都在函数的不同部分实现了这一点。完全有可能合并会错过这两个更改是相关的，因为它们位于代码的不同部分，我们得到了两者。现在我们的值增加了 2 而不是 1。
4. 持续集成的定义可以在这里找到：https://bit.ly/2JVRGiv。

5. 版本控制中的分支定义可以在这里找到：https://bit.ly/2NlAll8。

持续集成，按照定义进行实践时，意味着我们会定期、频繁地获得反馈。它使我们能够在整个工作日内深入了解代码的状态和系统的行为，但这是有代价的。
为了让 CI 发挥作用，我们必须足够频繁地提交我们的更改，以获得反馈和洞察力。这意味着工作方式非常不同。
而不是在功能“完成”或“准备生产”之前一直在持续集成和它的老大哥持续交付要求我们以小步进行更改并在每小步之后准备好使用的东西。这在某些重要方面改变了我们对系统设计的看法。
这种方法意味着设计我们的代码的过程更像是一种引导式进化，每一个小步骤都会给我们反馈，但不一定还包括一个完整的功能。对许多人来说，这是一个非常具有挑战性的观点转变，但当我们接受它时，这是一个解放的步骤，并且会对我们的设计质量产生积极的影响。
这种方法不仅意味着我们的软件始终是可发布的，并且我们经常收到关于我们工作质量和适用性的细粒度反馈，而且还鼓励我们以支持这种方法的方式设计我们的工作。

## 设计反馈
作为一种实践，我如此重视 TDD 的原因之一是它给我的设计质量的反馈。如果我的测试很难编写，那说明我的代码质量很重要。
我创建一个简单有效的测试的能力，以及我的设计的有效性，与我们认为在“好”代码中很重要的质量属性有关。我们可以长时间争论代码中“优质”的含义的详尽定义，但我认为我不需要这样做来表达我的观点。我建议以下属性几乎被认为是代码质量的标志；它们可能不是质量的唯一属性，但我相信您会同意我的观点，即它们很重要：

- 模块化
- 关注点分离
- 高内聚力
- 信息隐藏（抽象）
- 合适的耦合

我希望现在这个列表听起来很熟悉。它们不仅是代码中的“质量标志”，也是让我们管理复杂性的工具。这不是巧合！
那么如何将基于这些属性的“质量”放入代码中呢？在没有 TDD 的情况下，这完全取决于开发人员的经验、承诺和技能。
使用 TDD，根据定义，我们首先编写测试。如果我们不先编写测试，那么它就不是测试驱动的开发。
如果我们要先写测试，我们必须是一个奇怪的、愚蠢的人，让我们自己的生活更加困难。因此，我们将尝试以一种让生活更轻松的方式做到这一点。
例如，我们极不可能以某种方式编写测试，这意味着我们无法从正在测试的代码中获取结果。由于我们在编写任何非测试代码之前先编写测试，这意味着在创建测试的那一刻，我们也在设计代码的接口。我们正在定义我们代码的外部用户将如何与其交互。
由于我们需要测试的结果，因此我们将设计代码的方式使我们能够轻松获得我们感兴趣的结果。这意味着，在 TDD 中，编写代码会施加压力更具可测试性。可测试的代码是什么样的？
它是以下所有内容：

- 是模块化的
- 具有良好的关注点分离
- 展现高凝聚力
- 使用信息隐藏（抽象）
- 适当耦合

>  **测试的基本作用**
>
> 在经典的开发方法中，测试有时会作为项目结束时的练习，有时会留给客户，有时会因时间压力而几乎完全消失。
> 这种方法使反馈循环如此扩展，以至于它基本上没有用。编码或设计中引入的错误通常在开发团队完成项目并将维护交给一些生产支持团队之后才被发现。
> 极限编程 (XP) 及其对 TDD 和 CI 的应用彻底颠覆了这一点，将测试置于开发过程的前沿和中心。这将反馈循环减少到几秒钟，对错误提供几乎即时的反馈，反过来，如果做得好，可以消除整类错误，在没有 TDD 的情况下，这些错误通常会进入生产环境。
> 在这种思想流派中，测试推动了开发过程，更重要的是，推动了软件本身的设计。使用 TDD 编写的软件看起来与没有编写的软件不同。为了使软件可测试，重要的是要确保可以评估预期的行为。
> 这将设计推向了特定的方向。 “可测试”的软件是模块化的，松散耦合的，表现出高内聚性，具有良好的关注点分离，并实现了信息隐藏。这些也恰好是被广泛认为是软件质量标志的属性。因此，TDD 不仅评估了软件的行为，还提高了其设计的质量。
> 软件测试非常重要。软件是脆弱的，人类经验中很少有其他东西是脆弱的。最微小的缺陷——一个不合适的逗号——都可能导致灾难性的失败。
> 软件也比大多数人类创造复杂得多。一架现代客机由大约 400 万个零件组成。现代沃尔沃卡车中的软件大约有 8000 万行代码，每行代码都由多个指令和变量组成。
> 当 Kent Beck 在 1990 年代后期在他的书中描述 TDD 时，TDD 并不是一个新想法。 Alan Perlis 在 1968 年的北约软件工程会议上描述了类似的东西，但 Beck 引入了这个概念并对其进行了更深入的描述，因此它被更广泛地采用。
> TDD 在许多方面仍然是一个有争议的想法，但数据相当不错。这种方法可以显着减少系统中的错误数量，并对系统设计质量产生积极影响。

TDD 施加压力以创建客观上“更高质量”的代码。 这与软件开发人员的才能或经验无关。 它不会让糟糕的软件开发人员变得更好，但它确实让“糟糕的软件开发人员”变得更好，让“伟大的软件开发人员”变得更好。
TDD 以及测试驱动开发方法的其他方面对我们创建的代码的质量有重要影响。 这是优化以获得更好反馈的效果，但这种效果并不止于此。

## 架构反馈

在我们构建的系统的广泛软件架构以及我们做出的详细代码级设计决策中，可以看到反馈驱动方法应用的更微妙的影响。
持续交付是一种高性能、反馈驱动的开发方法。它的基石之一是我们应该生产随时可以发布到生产环境的软件。这是一个高标准，需要非常高的频率和质量的反馈。
实现这一目标需要组织改变其开发方法的许多不同方面。出现的两个方面可能被认为是我们构建的系统的架构质量。我们需要认真对待系统的可测试性和可部署性。
我建议与我合作的公司至少每小时创建一次“可发布的软件”。这意味着我们必须能够每小时运行数十个甚至数十万个测试。
假设资金和计算能力无限，我们可以并行运行我们的测试以优化快速反馈，但有一个限制。我们可以想象每个测试独立运行，并与所有其他测试并行运行。
有些测试需要测试系统的部署和配置，因此反馈时间的限制情况是基于部署系统和启动并运行的时间，以及运行最慢测试用例的时间。
如果任何单个测试的运行时间超过一个小时，或者您的软件部署时间超过一个小时，那么无论您在硬件上花多少钱，都不可能如此快速地运行您的测试。
因此，我们系统的可测试性和可部署性给我们收集反馈的能力增加了限制。我们可以选择将我们的系统设计为更易于测试和更易于部署，从而使我们能够在更短的时间内更有效地收集反馈。
我们更喜欢需要几秒钟或几毫秒来运行和部署在几分钟内完成的测试，甚至更好的是几秒钟。
在可部署性和可测试性方面实现这些级别的性能需要团队的工作和关注，以及开发组织对持续交付理念的承诺，但通常还需要一些仔细的架构思考。
有两种有效的途径：您可以努力构建单体系统并优化它们的可部署性和可测试性，或者您可以将它们模块化为单独的、单独的“可部署单元”。第二种方法是微服务流行背后的驱动思想之一。
微服务架构方法允许团队彼此独立地开发、测试和部署他们的服务；它还在组织上使它们脱钩，使公司能够更有效地发展。
微服务的独立性是一个显着的好处，但也是一个显着的复杂性。根据定义，微服务是可独立部署的代码单元。这意味着我们不能一起测试它们。
将持续交付应用于单体系统是有效的，但它仍然要求我们可以每天进行多次小的更改并对其进行多次评估。对于更大的系统，我们仍然需要能够与代码库中的许多其他人一起工作，因此我们需要良好的设计和持续集成将带来的保护。
无论我们选择将系统分解为更小、更独立的模块（微服务），还是开发更高效但耦合更紧密的代码库（单体），这两种方法都会对我们创建的软件系统的架构产生重大影响。
在单体和微服务这两种方法中采用持续交付，促进了更模块化、更好抽象、更松散耦合的设计，因为只有这样，您才能足够有效地部署和测试它们以实践持续交付。
这意味着在我们的开发方法中重视和优先考虑反馈可以促进更明智、更有效的架构决策。
这是一个深刻而重要的思想。这意味着通过采用一些通用原则，我们可以对我们创建的系统的质量产生重大的、可衡量的影响。通过将流程、技术、实践和文化集中在高质量反馈的有效交付上，我们可以创建质量更好的软件，并以更高的效率做到这一点。

## 更喜欢早期反馈
一般来说，尽早获得明确的反馈是一种有效的做法。在编码时，我可以使用我的开发工具在键入时突出显示代码中的错误。这是最快、最便宜的反馈循环，也是最有价值的反馈循环之一。我可以通过使用类型系统之类的技术来利用这一点，为我的工作质量提供快速、明确的反馈。
我可以在我的开发环境中正在处理的代码区域中运行测试（或多个测试），并非常快速地获得反馈——通常不到几秒钟。
我的自动化单元测试是作为 TDD 方法的输出创建的，在我工作时给我第二级反馈，并在我的本地开发环境中定期运行它们。
一旦我提交了我的代码，我的全套单元和其他提交测试就会运行。这为我提供了更彻底但在时间方面成本更高的验证，以确保我的代码与其他人的代码一起工作。
验收测试、性能测试、安全测试以及我们认为对理解更改的有效性很重要的任何其他内容，使我们对工作的质量和适用性更加有信心，但代价是需要更长时间才能返回结果。
因此，倾向于识别缺陷，首先是在编译能力（在我们的开发环境中识别），然后是单元测试，只有在这些验证成功之后，在其他形式的更高级别测试中，意味着我们可以尽快失败获得最高质量、最有效的反馈。
持续交付和 DevOps 从业者有时将这种偏好早期失败的过程称为左移，尽管我更喜欢不那么晦涩的“快速失败！”

## 产品设计反馈
认真对待对我们创建的系统质量的反馈的影响是重要而深远的，但最终，软件开发人员不会因为制作设计精美、易于测试的软件而获得报酬。我们的报酬是为雇用我们的组织创造某种价值。
这是大多数传统组织中更注重业务的人员和更注重技术的人员之间关系的核心紧张关系之一。
这是一个问题，通过关注使有用的想法持续交付到生产中来解决。
我们怎么知道我们拥有的想法、我们创造的产品是好的？
真正的答案是，直到我们从我们的想法的消费者（我们的用户或客户）那里得到反馈之前，我们都不知道。
关闭围绕产品创意创造和将价值交付到生产中的反馈循环是持续交付的真正价值。这是它在世界各地的组织中如此受欢迎的原因，而不是更狭窄（尽管仍然很重要）的技术优势。
应用采用和优化快速、高质量反馈的原则，使组织能够更快地学习；发现哪些想法对他们的客户有效，哪些无效；并调整他们的产品以更好地满足客户的需求。
世界上最有效的软件开发组织确实非常重视这一方面。
将遥测添加到我们的系统中，使我们能够收集有关使用我们系统的哪些功能以及如何使用它们的数据，现在已成为常态。从生产系统收集信息（反馈）不仅可以诊断问题，还可以帮助我们更有效地设计下一代产品和服务，将组织从“业务和 IT”转变为“数字业务”。这在许多领域变得如此复杂，以至于收集到的信息通常比所提供的服务更有价值，并且可以提供对客户需求、需求和行为的洞察，甚至客户自己也没有意识到。

## 组织和文化中的反馈
软件开发的可测量性长期以来一直是一个问题。我们如何衡量成功，我们如何衡量改进？我们如何判断我们所做的更改是否有效？
在软件开发的大部分历史中，这要么基于测量易于测量的事物（例如，“代码行数”或“开发人员天数”或“测试覆盖率”），要么基于猜测并在此基础上做出主观决策直觉。问题在于，无论这意味着什么，这些事情都与成功没有任何现实关联。
更多的代码行并不意味着更好的代码；这可能意味着更糟糕的代码。除非测试正在测试有用的东西，否则测试覆盖率是没有意义的。我们在软件上付出的努力与它的价值无关。因此，猜测和主观性可能与这些措施一样好。
那么我们怎样才能做得更好呢？在没有某种成功衡量标准的情况下，我们如何建立有用的反馈？
有两种方法可以解决这个问题。第一个已经在敏捷开发圈中建立了一段时间。我们承认这些判断有些主观，但我们尝试采取一些合理的纪律来减轻主观性。这种方法的成功不可避免地与所涉及的个人密不可分。它是“个体和交互胜过流程和工具。”6
这个策略在历史上很重要，它使我们摆脱了更公式化、大仪式的软件开发方法，并且作为基本原则仍然很重要。
敏捷的开发方法将团队、工作中的人带入反馈循环，以便他们可以观察他们行动的结果，反思他们，并随着时间的推移完善他们的选择以改善他们的情况。这种主观的、反馈驱动的方法是“检查和适应”这一最基本的敏捷理念的基础。
我将添加到这种主观反馈方法以提高反馈质量的一个小改进是具体说明其性质。
例如，如果您的团队有改进其处理方法的想法，请参考科学家的书，并清楚您认为自己现在所处的位置（当前状态）以及您希望成为的位置（目标状态）。描述一个你认为会带你走向正确方向的步骤。决定您将如何决定您是离目标状态更近还是更远。迈出这一步并检查您是离目标更近还是更远，然后重复直到到达目标。 7
这是科学方法的一种简单、轻量级的应用。这应该是显而易见的。这应该是“母性和苹果派”，但这不是大多数组织中的大多数人所做的。当人们应用这种方法时，他们会得到更好的结果。例如，这是支持精益思想 8 的理念，特别是“丰田方式”，即彻底改变了汽车行业和许多其他行业的精益生产方法。
多年来，我一直相信，这就是我们真正能够应用仍然主观但更有条理的方法来解决问题的全部方法。近年来，谷歌 DORA 小组的出色工作改变了我的看法。随着更注重技术的变化。

6.“个体和交互胜过流程和工具”是敏捷宣言中的一个声明；请参阅 https://agilemanifesto.org/。

7. Mike Rother 在他的著作 Toyota Kata 中更详细地描述了这种方法；见 https://amzn.to/2FvsI74。然而，它实际上只是科学方法的改进。

8. 精益思维是与精益生产和精益过程一致并与之相关的思想的统称。

9. DORA 小组设计了科学合理的数据收集和分析方法，该方法是“DevOps 状态报告”的核心，该报告自 2014 年起每年发布一次。他们的方法和发现在 Accelerate: The Science 一书中有更详细的描述精益软件和 DevOps。

这并不意味着之前的方法是多余的。必须应用人类的创造力，数据驱动的决策也可能是愚蠢的，但我们可以用数据来告知和加强主观评估，并在我们对成功的评估中更加量化。
第 3 章中描述的稳定性和吞吐量度量很重要。它们并不理想，它们运行的模型是相关模型，而不是因果模型。我们没有证据说“X 导致 Y”；它比那更复杂。还有很多问题我们希望能够更定量地回答，但不知道如何回答。稳定性和吞吐量很重要，因为它们是我们目前理解的最好的，而不是因为它们是完美的。
尽管如此，这是向前迈出的一大步。现在，我们可以使用这些衡量效率和质量的指标，即衡量合理、有用结果的指标，来评估几乎所有类型的变化。如果我的团队决定重新组织他们的位置以改善沟通，我们可以监控稳定性和吞吐量以查看它们是否发生变化。如果我们想尝试一些新技术，它是否会让我们更快地生产软件，提高我们的吞吐量数字，或者提高我们的质量以提高我们的稳定性数字？
这种反馈作为“适应度函数”是非常宝贵的，可以指导我们朝着 DORA 模型预测的更好结果的方向努力。随着我们不断发展我们的流程、技术、组织和文化，通过在稳定性和吞吐量方面跟踪我们的分数，我们可以确保我们所做的改变实际上是有益的。我们从时尚或猜测的受害者转变为更像工程师。
这些变化仍然是我们生产的软件真正价值的代表。该价值体现在我们的更改对用户的影响中。然而，这些变化衡量了我们工作的重要属性，并且不会被操纵。如果您的稳定性和吞吐量数字良好，那么您的技术交付也很好。因此，如果您没有以良好的稳定性和吞吐量获得成功，那么您的产品创意或业务策略就有问题。

## 概括

反馈对我们的学习能力至关重要。如果没有快速有效的反馈，我们只能猜测。反馈的速度和质量都很重要。如果反馈太晚，则无济于事。如果它是误导性的或错误的，我们根据它做出的决定也将是错误的。我们通常不会考虑我们需要哪些反馈来告知我们的选择，以及我们收集的反馈时间表到底有多重要。
持续交付和持续集成都是基于优化我们的开发过程以最大限度地提高我们收集的反馈的质量和速度的想法。
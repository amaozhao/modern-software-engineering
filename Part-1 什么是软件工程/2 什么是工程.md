多年来，我一直在与人们谈论软件工程。因此，我经常参与数量惊人的关于桥梁建设的对话。他们通常以“是的，但软件不是桥梁建设”这句话开头，好像这是某种启示。
当然，软件工程与造桥不一样，但大多数软件开发人员认为的造桥也不同于真正的造桥。这种对话实际上是生产工程和设计工程之间的一种混淆形式。
当所涉及的学科处理物理事物时，生产工程是一个复杂的问题。您需要将这些物理事物创建到一定的精度和质量水平。
您需要将小部件交付到空间中的某个特定位置、特定时间、定义的预算等。您需要根据实际情况调整理论想法，因为您的模型和设计被发现缺乏。
数字资产完全不同。虽然这些问题有一些类似的问题，但对于数字人工制品，这些问题要么不存在，要么可以变得非常简单。任何类型的数字资产的生产成本基本上都是免费的，或者至少应该是免费的。

## 产品不是我们的问题

对于大多数人类的努力来说，“东西”的生产是最困难的部分。设计一辆汽车、一架客机或一部手机可能需要付出努力和独创性，但将最初的原型设计和想法投入批量生产的成本要高得多，也复杂得多。
如果我们的目标是以任何形式的效率来做到这一点，则尤其如此。由于这些困难，我们这些工业时代的产品和工业时代的思考者，不自觉地、几乎不假思索地担心任何重大任务的生产这一方面。
其结果是，在软件方面，我们一直在尝试将“生产式思维”应用于我们的行业。 Waterfall1 流程是软件的生产线。它们是批量生产的工具。它们不是发现、学习和实验的工具，它们不是或至少应该成为我们职业的核心。
除非我们的软件开发选择很愚蠢，否则对我们来说，生产就是触发构建！
它是自动的、一键式的、非常可扩展的，而且价格便宜，最好被认为是免费的。我们仍然可以犯错，但这些问题可以通过工具和技术来理解和很好地解决。
“生产”不是我们的问题。这使我们的学科与众不同。它还使它容易受到误解和误用的思维和实践，因为这种轻松的生产是如此不寻常。

## 设计工程，而不是生产工程
即使在现实世界中，大多数人认为的“桥梁建设”是不同的，如果桥梁建设者正在建造第一座新型桥梁。在这种情况下，您有两个问题：一个与软件开发相关，一个与软件开发无关。
首先，不是的——当建造第一座新型桥梁时，因为它是物理的，你会遇到所有的生产问题，以及我提到的更多问题。从软件的角度来看，这些都可以忽略。
第二，就桥梁建设而言，除了这些生产问题之外，如果您正在建造第一座新型桥梁，第二个真正困难的部分是新桥梁的设计。
这很困难，因为当您的产品是物理产品时，您无法快速迭代。在构建物理事物时，它们很难改变。
因此，其他学科的工程师采用建模技术。他们可能会选择建立小型物理模型，现在可能是他们设计的计算机模拟或各种数学模型。
在这方面，我们软件开发商有着巨大的优势。桥梁建造者可能会对其提议的设计进行计算机模拟，但这只是真实情况的近似值。他们的模拟，他们的模型，将是不准确的。我们作为软件创建的模型，我们对问题的计算机模拟，是我们的产品。
1. 应用于软件开发的瀑布式是一种分阶段的、顺序的方法，通过将工作分解为一系列不同的阶段，并在每个阶段之间进行明确定义的交接。这个想法是你依次处理每个阶段，而不是迭代。

我们不必担心我们的模型是否符合现实；我们的模型是我们系统的现实，因此我们可以验证它们。我们无需担心更改它们的成本。它们是软件；因此，至少与桥梁相比，它们更容易改变。
我们是一门技术学科。我们喜欢在这种情况下考虑自己，我猜大多数自认为是专业软件开发人员的人可能在他们的教育中已经掌握了一些科学知识。
尽管如此，很少有软件开发是考虑到科学理性主义的。部分原因是我们在历史上犯了一些错误。部分原因是我们假设科学是困难的、昂贵的，并且在正常的软件开发计划范围内是不可能实现的。
这里的部分错误是假设某种程度的理想主义精确度，这在任何领域都是不可能的，更不用说软件开发领域了。我们犯了追求数学精度的错误，这与工程不是一回事！

> **数学工程**
>
> 在 1980 年代末和 1990 年代初，有很多关于更多编程结构思想的讨论。对软件工程意义的思考继续研究我们生成代码的方式。具体来说，我们如何才能更有效地识别和消除设计和实现中的问题？
> 形式方法成为一种流行的想法。当时，大多数大学课程都会教授正式方法。形式化方法是一种构建软件系统的方法，其中内置了对所编写代码的数学验证。这个想法是证明代码是正确的。
> 这样做的一个大问题是，虽然为复杂系统编写代码很困难，但编写定义复杂系统行为并证明其正确性的代码就更难了。
> 形式化方法是一个吸引人的想法，但实际上，它们并没有在一般软件开发实践中得到广泛采用，因为在生产点，它们使代码更难生成，而不是更少。
> 不过，更哲学的论点有点不同。软件是不寻常的东西；它显然吸引了那些经常也喜欢数学思维的人。因此，对软件采用数学方法的吸引力是显而易见的，但也有一定的局限性。
> 考虑一个现实世界的类比。现代工程师将使用他们可以使用的所有工具来开发新系统。他们将创建模型和模拟，并计算数字以确定他们的系统是否能正常工作。他们的工作在很大程度上受到数学的启发，但随后他们会真正尝试一下。
> 在其他工程学科中，数学当然是一个重要的工具，但它并不能取代测试和从现实世界经验中凭经验学习的需要。现实世界中存在太多差异，无法完全预测结果。如果仅靠数学就足以设计一架飞机，那么这就是航空航天公司会做的事情，因为这比建造真正的原型要便宜，但他们不这样做。相反，他们广泛使用数学来告知他们的想法，然后他们通过测试真实设备来检查他们的想法。软件与飞机或太空火箭并不完全相同。
> 软件是数字化的，主要运行在称为计算机的确定性设备上。所以对于一些狭窄的上下文，如果问题足够简单、足够约束、足够确定性和足够低的可变性，那么形式方法可以证明一个案例。这里的问题是整个系统的确定性程度。如果系统在任何地方并发，在任何地方与“现实世界”（人）交互，或者只是在一个足够复杂的领域中工作，那么“可证明性”会迅速爆炸而变得不切实际。
> 因此，我们采取与航空航天同事相同的课程，尽可能应用数学思维，并采用数据驱动的、务实的、经验性的、实验性的学习方法，使我们能够随着系统的逐步增长而调整系统。

在我写这本书的时候，SpaceX 正忙着炸毁火箭，同时努力完善星际飞船。 2 它确实已经建立了几乎所有火箭设计、发动机、燃料输送系统、发射基础设施等方面的数学模型否则，然后它会测试它们。
即使是看似简单的事情，比如从 4 毫米不锈钢切换到 3 毫米不锈钢，听起来也像是一个非常可控的变化。 SpaceX 可以获得有关金属抗拉强度的详细数据。它拥有从测试中收集的经验和数据，可以准确显示由 4 毫米钢制成的压力容器的强度。
然而，在 SpaceX 处理完这些数字之后，它仍然构建了实验原型来评估差异。它将这些测试件加压至破坏，以查看计算是否准确并获得更深入的了解。 SpaceX 收集数据并验证其模型，因为这些模型肯定会以某种深奥、难以预测的方式出错。
我们相对于所有其他工程学科的显着优势意味着我们在软件中创建的模型是我们工作的可执行结果，因此当我们测试它们时，我们正在测试我们的产品，而不是我们对产品现实的最佳猜测.
如果我们仔细地隔离我们感兴趣的系统部分，我们就可以在与它在生产中暴露的完全相同的环境中对其进行评估。因此，与任何其他学科相比，我们的实验模拟可以更准确、更准确地表示我们系统的“真实世界”。
2. 在撰写本文时，SpaceX 正在开发一种新的完全可重复使用的航天器。 SpaceX 的目的是创建一个系统，让人们能够前往火星并在火星上生活，并探索太阳系的其他部分。它采用了一种有意的快速、迭代的工程风格来快速创建和评估一系列快速生产的原型。这是工程知识极限下的极端形式的设计工程，并展示了创造新事物所需的迷人示例。

在名为“真正的软件工程”3 的精彩演讲中，Glenn Vanderburg 表示，在其他学科中，“Efdddssngineering 意味着有效的东西”，而对于软件而言，情况恰恰相反。
范德堡继续探索为什么会这样。他描述了一种软件工程的学术方法，这种方法非常繁重，以至于几乎没有实践过它的人会推荐它用于未来的项目。
它是重量级的，根本没有为软件开发过程增加任何重要的价值。范德堡用一句很有说服力的话说：
[学术软件工程]之所以奏效，是因为敏锐的人，关心，愿意绕过这个过程。

这不是任何合理定义的工程。
范德堡 (Vanderburg) 对“工程即行之有效的东西”的描述很重要。如果我们选择标识为“工程”的实践不允许我们更快地制作更好的软件，那么它们就没有资格成为工程！
与所有物理生产过程不同，软件开发完全是一种发现、学习和设计的练习。我们的问题是探索问题，所以我们比飞船设计师更应该应用探索技术而不是生产工程技术。我们的只是一门设计工程学科。
因此，如果我们对工程的理解经常被混淆，那么工程的真正含义是什么？

> 第一位软件工程师
>
> 在玛格丽特·汉密尔顿领导阿波罗飞行控制系统开发的时期，没有“游戏规则”可以遵循。她说：“我们随着每一个新的相关发现发展了我们的‘软件工程’规则，而 NASA 的高层管理规则从‘完全自由’变成了‘官僚矫枉过正’。”
> 目前很少有此类复杂项目的经验可供参考。因此，该团队经常开辟新天地。汉密尔顿和她的团队面临的挑战是深远的，在 1960 年代，在 Stack Overflow 上找不到答案。
> 汉密尔顿描述了一些挑战：
> 太空任务软件必须经过人工评估。它不仅必须工作，而且必须第一次工作。不仅软件本身必须非常可靠，还需要能够实时执行错误检测和恢复。我们的语言让我们敢于犯最微妙的错误。我们自己制定了构建软件的规则。我们从错误中学到的东西充满惊喜。
>
> 3. https://youtu.be/RhdlBHHimeM
>
> 与此同时，与其他更“成熟”的工程形式相比，软件通常被视为一种“不良关系”。汉密尔顿创造软件工程一词的原因之一是试图让其他学科的人更认真地对待软件。
> 汉密尔顿方法背后的驱动力之一是关注事情是如何失败的——我们出错的方式。
> 我对错误很着迷，我的无休止的消磨时间是导致特定错误或错误类别发生的原因以及将来如何防止它发生。
>
> 这种关注基于科学合理的解决问题的方法。假设不是你可以第一次就计划和做对，而是你以怀疑的态度对待所有的想法、解决方案和设计，直到你对事情可能会出错的想法用完为止。有时，现实仍然会让您感到惊讶，但这是在起作用的工程经验主义。
> 汉密尔顿早期工作中体现的另一个工程原则是“安全失败”的想法。假设我们永远无法为每个场景编码，那么我们如何以允许我们的系统应对意外并仍然取得进展的方式进行编码？众所周知，尽管计算机在下降过程中过载，但汉密尔顿主动实施了这一想法，挽救了阿波罗 11 号任务，并使登月舱 Eagle 成功登陆月球。
> 当尼尔·阿姆斯特朗和巴兹·奥尔德林乘坐月球远足舱 (LEM) 向月球降落时，宇航员和任务控制中心之间进行了交流。当 LEM 接近月球表面时，计算机报告了 1201 和 1202 警报。宇航员询问他们是否应该继续或中止任务。
> NASA 犹豫了一下，直到其中一名工程师大喊“去！”因为他了解软件发生了什么。
> 在阿波罗 11 号上，每次出现 1201 或 1202 警报时，计算机都会重新启动，重新启动重要的东西，例如驾驶下降引擎和运行 DSKY 让机组人员知道发生了什么，但没有重新启动所有错误安排的交会雷达作业。 MOCR 的 NASA 人员知道——因为 MIT 已经广泛测试了重启能力——任务可以继续进行。 4
>
> 这种“故障安全”行为被编码到系统中，没有任何具体预测它何时或如何有用。
> 因此，汉密尔顿和她的团队引入了更多以工程为主导的思维方式的两个关键属性，即经验学习和发现以及想象事情可能出错的习惯。

4. Source: “Peter Adler” (https://go.nasa.gov/1AKbDei)

## 工程的工作定义
工程一词的大多数词典定义都包含常用词和短语：“数学应用”、“经验证据”、“科学推理”、“在经济约束内”。
我提出以下工作定义：
工程是应用经验的、科学的方法来为实际问题寻找有效、经济的解决方案。

这里所有的话都很重要。工程学是应用科学。这是实用的。使用“经验”意味着学习和推进对解决问题的理解和解决方案。
工程创造的解决方案不是抽象的象牙塔式的东西；它们是实用的，适用于问题和背景。
它们是高效的，并且它们是在了解情况的经济学并受其约束的情况下创建的。

## 工程 != 代码

对软件开发中工程的含义的另一个常见误解是，工程只是输出——代码或者可能是它的设计。
这个解释太狭隘了。工程对SpaceX意味着什么？这不是火箭；它们是工程产品。工程是创造它们的过程。火箭肯定有工程，它们肯定是“工程结构”，但我们不会只将焊接金属的行为视为工程，除非我们对这个话题有一个奇怪的狭隘看法。
如果我的定义有效，那么工程就是将科学理性主义应用于解决问题。真正发挥工程作用的是“解决问题”，而不仅仅是解决方案本身。它是过程、工具和技术。正是思想、哲学和方法共同构成了一门工程学科。
在写这本书时，我有一个不寻常的经历：我在我的 YouTube 频道上发布了一个关于游戏失败的视频，该视频比我的大多数视频更受欢迎。
我得到的最常见的负面反馈是，说这是“软件工程的失败”，是我在责怪程序员而不是他们的经理。我的意思是，这是整个软件生产方法的失败。计划很糟糕，文化很糟糕，代码很糟糕（显然有很多错误）。
因此，对于本书，当我谈论工程时，除非我特别限定它，否则我指的是制作软件所需的一切。流程、工具、文化——所有这些都是整体的一部分。

> **编程语言的演变**
>
> 软件工程的早期努力主要集中在创建更好的编程语言。第一台计算机在硬件和软件之间几乎没有或根本没有分离。它们是通过将电线插入接线板或翻转开关来编程的。
> 有趣的是，这项工作通常交给“计算机”，通常是女性，她们在计算机（作为机器）出现之前就已经完成了计算（数学）。
> 然而，这低估了他们的作用。此时，由组织中“更重要”的人指定的“程序”通常是“我们想解决这个数学问题”的形式。工作的组织，以及后来如何将其转化为适当的机器设置的细节，都留给了这些人类“计算机”。他们是我们学科的真正先驱！
> 我们将使用不同的语言来描述今天的这些活动。我们会将传递给从事工作的人的描述描述为需求，将制定解决问题的计划的行为描述为编程，而将“计算机”描述为这些早期电子计算机系统的第一个真正的程序员。
> 下一步是转向“存储程序”及其编码。这是纸带和穿孔卡片的时代。在程序中采用这种存储介质的第一步仍然是非常核心的。程序是用机器代码编写的，并在被送入机器之前存储在磁带或卡上。
> 可以在更高抽象层次上捕捉想法的高级语言是下一个重大进步。这使程序员能够更快地取得进展。
> 到 1980 年代初，几乎涵盖了语言设计中的所有基本概念。这并不意味着在此之后没有任何进展，而是已经涵盖了大部分重要的想法。尽管如此，软件开发仍继续将语言作为我们学科的核心思想。
> 有几个重要的步骤肯定会影响程序员的生产力，但可能只有一步使 Fred Brooks 提高了 10 倍。那是从机器代码到高级语言的一步。
> 沿着这条进化路径的其他步骤很重要，例如过程编程、面向对象和函数式编程，但所有这些想法已经存在很长时间了。
> 我们行业对语言和工具的痴迷已经损害了我们的职业。这并不意味着语言设计没有进步，但是语言设计中的大多数工作似乎都集中在错误的事情上，例如句法进步而不是结构进步。
> 在早期，当然，我们需要学习和探索什么是可能的，什么是有意义的。然而，从那时起，人们付出了很多努力，但进展相对较小。当 Fred Brooks 说没有 10 倍的改进时，他论文的其余部分专注于我们可以做些什么来克服这个限制：
> 控制疾病的第一步是用细菌理论取代恶魔理论和体液理论。这一步，希望的开始，本身就破灭了所有神奇解决方案的希望。
>
> ...系统应该首先运行，即使它除了调用正确的虚拟子程序集之外没有任何用处。然后，一点一点地充实它，子程序依次被开发成动作或调用下面级别的空存根。
>
> 这些想法基于更深刻、更深刻的想法，而不是语言实现的琐碎细节。
> 这些问题更多地与我们学科的哲学和一些基本原则的应用有关，无论技术的性质如何，这些原则都适用。

## 为什么工程很重要？
另一种思考方式是考虑我们如何生产对我们有帮助的东西。在人类历史的绝大部分时间里，我们创造的一切都是工艺的产物。工艺是创造事物的有效方法，但它有其局限性。
Craft非常擅长创造“一次性”物品。在以工艺为基础的生产系统中，每件商品都不可避免地是独一无二的。从最纯粹的意义上讲，这适用于任何生产系统，但在基于工艺的方法中更是如此，因为生产过程的精度和可重复性通常较低。
这意味着单独制作的工件之间的差异量更大。即使是最精湛的工匠也会创造出只有人类水平的精确度和宽容度的物品。这严重影响了基于工艺的系统可靠地复制事物的能力。格蕾丝·霍珀说：
对我来说，编程不仅仅是一门重要的实用艺术。这也是知识基础方面的一项巨大事业。

## “工艺”的局限

我们经常对基于手工艺的生产产生情绪反应。作为人类，我们喜欢方差；我们喜欢这种珍贵的手工制品体现了创造它的工匠的技能、爱和关怀的感觉。
然而，从根本上说，以工艺为基础的生产从根本上是低质量的。一个人，无论多么有才华，都不如机器那么准确。
我们可以制造出能够操纵单个原子，甚至亚原子粒子的机器，但如果人类能够以 1/10 毫米的精度手动生产某些东西，那将是非常有天赋的。 5
这种精度在软件中有何影响？让我们想想当我们的程序被执行时会发生什么。人类可以在大约 13 毫秒的限制内感知变化，任何变化。处理图像或对某事做出反应需要数百毫秒。 6
在撰写本文时，大多数现代消费级计算机的时钟周期约为 3GHz。即每秒 30 亿个周期。现代计算机是多核的，并行操作指令，因此通常每个周期处理多条指令，但让我们忽略这一点，并想象一下，为了简单起见，每条机器指令在寄存器之间移动值，添加它们或引用一些缓存一块内存，需要一个时钟周期。
即每秒 30 亿次操作。如果我们进行数学运算并计算出现代计算机在人类感知任何外部事件的绝对最短时间内可以处理多少条指令，那么这个数字就是 39,000,000 条指令！
如果我们将我们的工作质量限制在人类尺度的感知和准确性上，我们充其量只能以 1:(3900 万) 的比率对正在发生的事情进行抽样。那么，我们错过某些东西的机会有多大？

## 精度和可扩展性
工艺和工程之间的这种差异突出了在软件环境中很重要的工程的两个方面：精度和可扩展性。
精度是显而易见的：通过应用工程技术，我们可以以比手动更高的细节分辨率来操纵事物。可扩展性可能不是那么明显，但更为重要。工程方法不像基于工艺的方法那样受到限制。
任何依赖于人的能力的方法的局限性最终都会受到人的能力的限制。如果我致力于实现非凡的成就，我可能会学会画一条线，锉一块金属，或将皮革汽车座椅缝到一毫米以内，但无论我多么努力，无论我多么有天赋，都有人类肌肉和感官的精确度存在严格限制。
然而，工程师可以制造一台机器来制造更小、更精确的东西。我们可以制造机器（工具）来制造更小的机器。
这种技术可以一直扩展到量子物理学的极限，一直扩展到宇宙学的极限。至少在理论上，没有什么可以阻止我们通过工程应用来操纵原子和电子（就像我们已经做的那样）或恒星和黑洞（就像我们有一天可能做的那样）。
5. 原子的大小各不相同，但通常以数十皮米 (1 x 10^-12m) 为单位。所以，最好的人类手工艺品比一台好的机器精度低 1000 万倍。

6.“实时有多快？人类感知和技术，”https://bit.ly/2Lb7pL1

为了更清楚地将这一点放在软件的上下文中，如果我们非常熟练并且非常努力地训练，我们也许可以足够快地输入文本和单击按钮来测试我们的软件，速度可以想象能够进行测试我们的软件在几分钟内。为了比较，让我们想象一下我们可以每分钟对我们的软件进行一次测试（这不是我能想象自己能够维持很长时间的速度）。
如果我们可以每分钟运行一次测试，那么与计算机相比，我们的测试不足数十万次，甚至可能是数百万次。
我已经构建了在大约 2 分钟内运行大约 30,000 个测试用例的系统。我们本可以进一步扩大规模，但没有理由这样做。谷歌声称每天运行 1.5 亿次测试执行。这相当于每分钟 104,166 次测试。7
我们不仅可以使用计算机进行比人类快数十万倍的测试，而且只要我们的计算机有电，我们就可以保持这种速度。那是可扩展的！

## 管理复杂度

还有另一种工程规模化的方式，而工艺则没有。工程思维倾向于引导我们划分问题。在 1860 年代美国内战之前，如果你想要一把枪，你就去找枪匠。枪匠是一个工匠，他通常是一个男人！
枪匠会为你制造一整支枪。他会了解那把枪的方方面面，这对你来说是独一无二的。他可能会给你一个子弹的模具，因为你的子弹会与其他人的不同，并且特定于你的枪。如果您的枪有螺丝，那么几乎可以肯定，每一个都与其他所有不同，因为它是手工制作的。
美国内战在当时是独一无二的。这是第一次大规模生产武器的战争。
有一个想向北方各州出售步枪的人的故事。他是一位创新者，而且似乎有点表演者。他去国会提出他的理由，以获得为北方各州军队制造步枪的合同。
他带着一袋装满步枪零件的袋子。作为向国会议员介绍的一部分，他将装满组件的袋子倒在国会的地板上，并要求国会议员从一堆组件中选择组件。他用这些部件组装了一支步枪，赢得了合同，并发明了大规模生产。
这种标准化是第一次成为可能。很多事情必须发生才能使它成为可能。必须对机器（工具）进行设计，以制造在某些定义的公差范围内可重复相同的组件。设计必须是模块化的，以便组件可以组装，等等。
7.“谷歌持续集成测试现状”，https://bit.ly/3eLbAgB

结果是毁灭性的。美国内战本质上是第一次现代战争。数十万人因武器的大规模生产而丧生。这些武器比以前的那些更便宜，更容易维护和修理，而且更准确。
所有这一切都是因为它们的设计精度更高，而且还因为它们的数量更多。生产过程可以去技能化和扩大规模。工厂中的机器不需要技术熟练的工匠来制作每种武器，而是可以让技术水平较低的人制造出与大师相当精确的步枪。
后来，随着工具、生产技术、工程理解和纪律的增加，这些大规模生产的武器甚至超过了最伟大的工匠的质量和生产力，而且价格是任何人都能负担得起的。
一个简单的观点可能会将其解释为“需要标准化”，或者需要采用“软件的大规模生产”，但这又一次混淆了我们问题的基本性质。这与生产无关，而与设计有关。
如果我们像美国内战的武器制造商那样设计模块化和组件化的枪支，那么我们就可以更独立地设计该枪支的部件。从设计的角度而不是从生产工程或制造的角度来看，我们已经改进了对制造枪支复杂性的管理。
在这一步之前，如果枪匠大师级工匠想要改变其设计的某些方面，他们需要考虑整支枪。通过将设计组件化，内战制造商可以逐步探索变化，以逐步提高其产品的质量。 Edsger Dijkstra 说：
编程的艺术是组织复杂性的艺术。

## 度量的重复性和准确性

工程的另一个常见的方面，有时被用来拒绝工程作为适用于软件的想法，是可重复性。
如果我们能建造一台机器来可靠、准确地复制螺母和螺栓，我们就可以将它们生产出来，并且所有螺栓的副本都可以与生产的任何螺母的副本一起使用。
这是一个生产问题，并不真正适用于软件。然而，支撑这种能力的更基本的想法适用于软件。
为了使螺母和螺栓或其他任何东西需要可靠地协同工作，我们需要能够以一定的精度来测量物体。测量的准确性是任何学科工程的一个有利方面。
让我们暂时想象一个复杂的软件系统。运行几周后，假设系统出现故障。系统重新启动，两周后又以同样的方式再次失败；有一个模式。与以工程为重点的团队相比，以工艺为重点的团队将如何应对？
狡猾的团队可能会决定他们需要更彻底地测试软件。因为他们是用工艺术语思考的，他们想要的是清楚地观察失败。
这并不愚蠢；在这种情况下这是有道理的，但如何做到呢？对于此类问题，我见过的最常见的解决方案是创建称为浸泡测试的东西。浸泡测试的运行时间比正常的故障间隔时间长一点，假设我们的示例为三周。有时人们会尝试加快时间，以便浸泡会在更短的时间内模拟问题时期，但通常不会。
测试运行，两周后系统未能通过测试，最终确定并修复了错误。
这个策略有什么替代方案吗？嗯，是！
浸泡测试检测一种或另一种形式的资源泄漏。有两种检测泄漏的方法；您可以等待泄漏变得明显，或者您可以提高测量精度，以便在泄漏变得灾难性之前及早发现泄漏。
我最近厨房漏水了。它在管道中，埋在混凝土中。一旦混凝土充分浸湿，水开始在表面形成水坑，我们就检测到了泄漏。这是“明显”的检测策略。
我们请了一位专业人员来帮助我们修复泄漏。他带来了一个工具，一个工程解决方案。这是一个高度灵敏的麦克风，可以“聆听”地下泄漏的声音。
使用这个工具，他可以检测出埋在混凝土中的微弱的漏水嘶嘶声，具有足够的、超人的精度，使他能够在几英寸内确定位置，并挖出一条小沟，找到有缺陷的管道。
回到我们的例子：以工程为重点的团队将使用准确的测量，而不是等待坏事发生。他们将测量其软件的性能，以在泄漏成为问题之前检测泄漏。
这种方法有多种好处；这意味着在很大程度上避免了生产中的灾难性故障，但也意味着他们可以更快、更快地获得问题迹象和有关其系统健康状况的宝贵反馈。以工程为重点的团队无需进行数周的浸泡测试，而是可以在系统的定期测试期间检测泄漏，并在几分钟内获得结果。大卫·帕纳斯说：
软件工程通常被视为计算机科学的一个分支。这类似于将化学工程视为化学的一个分支。我们需要化学家和化学工程师，但他们是不同的。

## 工程、创意和工艺
考虑一般的工程和具体的软件工程，几年来我一直在探索其中的一些想法。我在软件会议上讨论过这个话题，偶尔在博客文章中写过这个话题。
我有时会从那些坚持软件工艺理念的人那里得到反馈。这种反馈通常是“你在忽视工艺方面遗漏了一些重要的东西”。
软件工艺的思想很重要。它们代表着远离之前盛大的、以生产为中心的软件开发方法的重要一步。我的观点不是软件工艺是错误的，而是不够的。
在某种程度上，这些辩论是从一个错误的前提开始的，我已经提到过这个前提。许多这些软件工匠犯了一个常见的错误，认为所有的工程都是为了解决生产问题。我已经讨论过这个问题；如果我们的问题是“设计工程”，那么与“生产工程”相比，这是一个非常不同、更具探索性和创造性的学科。
此外，不过，我的软件工匠对话者担心丢弃软件工艺带来的收益的危险——即，关注以下几点：

- 技能
- 创造力
- 创新的自由
- 学徒计划

这些事情对于任何有效、专业的软件开发方法都很重要。然而，它们不限于基于工艺的方法。软件工艺运动是通过重新关注重要的事情来改进软件开发的重要一步，前面列出的事情就是其中的一些重要事情。
由于 1980 年代和 1990 年代试图将某种命令和控制、以生产为中心的方法强加到软件开发中，这些想法已经丢失，或者至少被包含在内。这是一个糟糕的想法，因为尽管瀑布式流程和思维在步骤易于理解、可重复和可预测的问题中占有一席之地，但这与软件开发的现实关系很小或没有关系。
软件工艺更适合软件开发真正存在的问题类型。
基于工艺的问题解决方案的问题在于，它们不像基于工程的解决方案那样可扩展。
工艺可以产生好的东西，但只能在一定的范围内。
几乎所有人类活动中的工程学科都可以提高质量、降低成本，并且通常会提供更强大、更有弹性和更灵活的解决方案。
将技能、创造力和创新等想法仅与工艺联系起来是一个很大的错误。一般来说，工程师，但肯定是设计工程师，一直都在充分展示所有这些品质。这些属性是设计工程过程的核心。
因此，采用工程方法解决问题并不会以任何方式降低技能、创造力和创新的重要性。如果有的话，它放大了对这些属性的需求。
至于培训，我想知道我的软件狡猾的朋友是否认为大学毕业的新研究生工程师会立即负责设计新的桥梁或航天飞机？当然不是！
处于职业生涯初期的工程师将与更有经验的工程师一起工作。他们将学习他们学科的实用性，他们的手艺，甚至可能比工匠更多。
我看不到工艺和工程之间的紧张关系。如果你对工艺有相当正式的看法，有公会、学徒、熟练工和工匠大师，那么工程真的是下一步。随着科学理性主义的盛行，继 17 和 18 世纪的启蒙思想之后，工程学确实得到了提高，并具有更高的准确性和测量性。工程学是更具可扩展性、更有效的工艺产物。
如果你对工艺采取更通俗的定义——认为这里的工艺公平——那么质量或进步就没有真正的标准，所以工程也许更像是一个跳跃。
工程，特别是工程思维在设计中的应用，确实是我们的高科技文明与我们之前的农业文明之间的区别。工程学是一门学科，它使我们能够处理极其复杂的问题，并为它们找到优雅、有效的解决方案。
当我们将工程思维的原则应用于软件开发时，我们会看到质量、生产力和解决方案适用性的可衡量的显着改进。 8

## 为什么我们做的不是软件工程
2019年，埃隆马斯克的公司SpaceX做出了重大决定；它正在致力于创造航天器，有朝一日可以让人类在火星上生活和工作并探索太阳系的其他部分。 2019 年，它从用碳纤维建造星际飞船转为用不锈钢建造它们。碳纤维是一个非常激进的想法。他们做了很多工作，包括用这种材料建造原型燃料箱。不锈钢也是一个激进的选择。大多数火箭都是用铝制成的，因为它既轻便又坚固。
SpaceX 选择不锈钢而不是碳纤维基于三点：钢的每公斤成本显着降低；应对再入温度的高温性能优于铝；低温、低温性能明显优于两种替代方案。
8. Accelerate Book 描述了采用更严格的开发方法的团队如何比不采用更严格的开发方法的团队在新工作上花费“多 44% 的时间”。请参阅 https://amzn.to/2YYf5Z8。

碳纤维和铝在非常低和非常高的温度下明显弱于钢。
您最后一次听到有人为与软件创建相关的决定辩护，听起来甚至含糊不清是什么时候？
这就是工程决策的样子。它们基于合理的标准、特定温度下的强度或经济影响。它仍然是实验性的，它仍然是迭代的，它仍然是经验性的。
你根据之前的证据和你对这意味着什么的理论做出决定，然后你测试你的想法，看看它们是否有效。这不是一个完全可预测的过程。
SpaceX 建造了测试结构，然后对它们加压，先用水，然后用液氮，这样他们就可以测试材料（钢）及其制造过程的低温性能。设计工程是一种获取知识的深入探索性方法。

## 权衡
所有的工程都是优化和权衡的游戏。我们试图解决一些问题，不可避免地，我们将面临选择。在制造火箭时，SpaceX 最大的权衡之一是强度和重量之间的权衡。这是飞行器的常见问题，实际上对于大多数车辆而言。
了解我们面临的权衡是工程决策的一个重要的基本方面。
如果我们让我们的系统更安全，它就会更难使用；如果我们让它更分散，我们将花更多时间整合它收集的信息。如果我们增加更多的人来加速开发，我们将增加通信开销、耦合和复杂性，所有这些都会使我们慢下来。
在从整个企业系统到单个功能的各个粒度级别上，在软件生产中需要考虑的关键权衡之一是耦合。 （我们将在第 13 章中更详细地探讨这一点。）

## 进步的错觉

我们行业的变化程度令人印象深刻，但我的论点是，这种变化在很大程度上并不重要。
撰写本文时，我正在参加一个关于无服务器计算主题的会议。9 转向无服务器系统是一个有趣的过程；然而，AWS、Azure、Google 或其他任何人提供的工具包之间的区别并不重要。

9. 无服务器计算是一种提供“功能即服务”的基于云的方法。函数是唯一的计算单元，运行它们的代码是按需启动的。

采用无服务器方法的决定将对您的系统设计产生一些影响。你在哪里存储状态？你在哪里操纵它？您如何划分系统的功能？当设计单元是一个功能时，您如何组织和导航复杂的系统？
这些问题对你的努力的成功更有趣，也更重要，不管它是什么，比你如何指定功能或如何使用平台的存储或安全功能的细节。然而，我看到的几乎所有关于这个主题的演讲都是关于工具的，而不是系统的设计。
这就好像我是一个木匠，被告知槽头螺钉和十字头螺钉之间的重要区别，但没有被告知什么螺钉有用，何时使用它们以及何时选择钉子.
无服务器计算确实代表了计算模型向前迈进了一步。我不质疑。这本书是关于使我们能够判断哪些想法重要，哪些不重要的想法。
无服务器很重要有几个原因，但主要是因为它鼓励采用更模块化的设计方法，更好地分离关注点，尤其是在数据方面。
无服务器计算通过将计算从“每字节成本”转移到“每 CPU 周期成本”来改变系统的经济性。这意味着，或者应该意味着，我们需要考虑非常不同的优化。
与其通过规范化数据存储优化我们的系统以最小化存储，我们可能应该接受使用非规范化存储和最终一致性模式的更真实的分布式计算模型。这些事情很重要，因为它们会影响我们创建的系统的模块化。
工具的重要性仅取决于它们在一些更基本的事情上“移动表盘”的程度。

## 从工艺到工程的旅程
重要的是不要忽视工艺的价值。对细节的关注和关注是创造高质量作品所必需的。同样重要的是不要忽视工程对于提高工艺产品的质量和有效性的重要性。
莱特兄弟是第一个制造可控制的、比空气重的动力飞行器的人。他们是优秀的工匠和优秀的工程师。他们的大部分工作都基于经验发现，但他们也对设计的有效性进行了真正的研究。他们不仅是第一批制造飞行器的人，而且还是第一批建造风洞以测量机翼设计有效性的人。
机翼是一个非凡的结构。莱特兄弟的建筑是一个美丽的，虽然按照现代标准非常简陋，设备。它由木头和金属丝制成，并覆盖着用香蕉油制成的防风布。
它和风洞被用来加深他们对空气动力学理论基础的理解，建立在早期先驱的工作基础上。然而，总的来说，莱特兄弟的飞行器，尤其是机翼，是通过试错过程而非纯粹的理论设计来制造的。
在现代人看来，它更像是工艺的产物，而不是工程。这在一定程度上是正确的，尽管不完全正确。许多人尝试过基于工艺的方法来建造“飞行机器”，但都失败了。莱特兄弟成功的重要原因之一是他们采用了工程学。他们进行计算并创建和使用测量和研究工具。他们控制变量，以便加深理解并完善他们的飞行模型。然后他们创建了模型、滑翔机和风洞部件来测试并加深他们的理解。他们建立的原则并不完美，但他们不仅在实践上有所改进，而且在理论上也有所改进。
当莱特兄弟实现比空气更重的可控飞行时，他们的空气动力学研究使他们能够制造滑翔比为 8.3:1 的飞行器。 10
为了将其与现代飞机机翼进行比较，例如现代滑翔机的机翼：Wright Flyer 的机翼是下弧度的（一种缓慢的高升力机翼），按照现代标准，它很重，但其结构很轻。日。它使用简单的天然材料并达到了 8.3:1。
通过工程、经验发现和实验，以及材料科学、空气动力学理论的完善、计算机建模等，现代滑翔机将拥有碳纤维、高展弦比的机翼。它经过优化，既轻便又坚固，您可以清楚地看到它在产生升力时弯曲和弯曲。它可以实现超过 70:1 的滑翔比，比 Wright Flyer 好近九倍。

## 工艺还不够

工艺很重要，特别是如果你所说的工艺真的意味着创造力。我们的学科是一项极具创造性的努力，工程也是如此。我相信工程实际上是人类创造力和独创性的高度。如果我们的目标是在软件中创造伟大的作品，这就是我们需要的那种思维。

## 是时候重新思考了？
软件工程作为一门学科的演变并没有真正实现许多人所希望的。软件已经改变，并且正在改变世界。已经有一些精彩的工作和创新、有趣和令人兴奋的系统构建，但对于许多团队、组织和个人开发人员来说，并不总是清楚如何成功，甚至如何取得进展。
10. 滑翔比是衡量飞行器效率的一项指标。该比率是行驶距离与损失高度之间的比率。例如，飞机在（无动力）滑翔中每下降一英尺（或米），它将向前移动 8.3 英尺（或米）。请参阅 https://en.wikipedia.org/wiki/Lift-to-drag_ratio。

我们的行业充满了理念、实践、流程和技术。技术专家之间就最好的编程语言、架构方法、开发过程和工具展开了宗教战争。对于我们职业的目标和战略是什么或应该是什么，似乎往往只有一种松散的认识。
现代团队与他们的设计的进度压力、质量和可维护性作斗争。他们常常难以确定真正与用户接触的想法，并且他们没有时间去了解问题领域、技术以及将伟大的东西投入生产的机会。
组织经常努力从软件开发中获得他们想要的东西。他们经常抱怨开发团队的质量和效率。他们经常误解他们可以做些什么来帮助克服这些困难。
与此同时，我认为专家们之间相当深的共识，我重视他们的意见，关于一些不经常或至少不够清楚的基本想法。
也许是时候重新考虑其中一些基本原理了。我们学科的共同原则是什么？有哪些想法会在几十年内成为现实，而不仅仅是对当前这一代技术工具而言？
软件开发不是一项简单的任务，也不是同质的任务。但是，有些做法是通用的。有一些思考、管理、组织和实践软件开发的方法，对所有这些有问题的工作方面都有重大的、甚至是戏剧性的影响。
本书的其余部分旨在探索这些通用思想中的一些，并提供所有软件开发都应该通用的基本原则列表，无论问题域、工具、商业或质量需求如何。
在我看来，这本书中的想法代表了关于我们努力的本质的一些深刻的、基本的东西。
当我们把这些事情做对时，很多团队都会这样做，我们会看到团队成员的生产力更高，压力和倦怠更少，设计质量更高，我们创建的系统更具弹性。
我们构建的系统更能取悦他们的用户。我们看到生产中的错误大大减少，采用这些想法的团队发现，随着学习的发展，几乎可以更轻松地更改他们所使用的系统的任何方面。对于以这种方式实践的组织而言，这样做的最终结果通常是更大的商业成功。这些属性是工程的标志。
工程增强了我们的创造力、创造有用的东西、自信和高质量地前进的能力。它使我们能够探索想法并最终扩展我们创造事物的能力，以便我们可以构建更大、更复杂的系统。
我们正处于真正的软件工程学科的诞生阶段。如果我们抓住这个机会，我们就可以开始改变软件开发的实践、组织和教学方式。
这很可能是代际变化，但它对雇用我们的组织以及整个世界具有如此巨大的价值，我们必须尝试。如果我们可以更快、更经济地构建软件会怎样？如果该软件质量更高、更易于维护、适应性更强、更具弹性并且更适合用户的需求，那会怎样？

## 概括
在软件中，我们在某种程度上重新定义了工程的含义。 当然，在某些圈子里，我们已经开始将工程视为一种不必要的、繁重的和繁重的事情，会妨碍“真正的软件开发”。 其他学科中的真正工程与这些无关。 其他学科的工程师进步更快，而不是更少。 他们创造了更高质量的工作，而不是更低的。
当我们开始采用实用、理性、轻量级、科学的软件开发方法时，我们会看到类似的好处。 软件工程将特定于软件，但它也将帮助我们更快地构建更好的软件，而不是妨碍我们这样做。
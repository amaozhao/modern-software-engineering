当我考虑真正的软件工程学科应该意味着什么时，我不会在特定工具、编程语言、流程或图表技术方面考虑太多。相反，我想到了结果。
任何名副其实的软件工程方法都必须围绕我们学习、探索和试验想法的需要而构建。最重要的是，如果它不能帮助我们更快地构建更好的软件，那就是“时尚”而不是工程。工程是有效的东西；如果它不起作用，我们将对其进行更改，直到它起作用为止。
虽然我可能没有考虑特定的工具，但这并不意味着没有。本书建立在这样一个理念之上，即有一些智力“工具”可以普遍应用于软件开发，从而显着提高我们更快地构建更好软件的机会。所有的想法都不是平等的；有一些想法很糟糕，我们应该能够抛弃它们。
在本章中，我将检查我在整本书中谈到的一些想法。这些想法将本书中的所有其他内容结合在一起。如果你忽略我写的所有其他东西，只采用这些想法，并将它们作为你进行软件开发的基本原则，那么你会发现你得到了更好的结果，随着时间的推移，你会发现所有的我在这里写过的其他想法，因为它们是合乎逻辑的结果。

## 什么是软件开发？

软件开发当然不仅仅是了解与编程语言相关的语法和库。我们捕捉到的想法在很多方面比我们用来捕捉它们的工具更重要。毕竟，我们得到报酬是为了解决问题，而不是使用工具。
如果我们不知道它是否有效，那么出于任何目的编写软件意味着什么？
如果我们仔细检查我们编写的代码但从不运行它，那么我们就是把自己当作财富的人质。人类不是那样工作的。即使对于像人类口语这样的松散解释的语言，我们也总是会犯错误。你有没有写过任何东西——也许是一封电子邮件——在没有校对的情况下发送它，然后发现所有的语法错误或拼写错误，为时已晚？
我和我的编辑们非常努力地消除了本书中的错误，但我很确定您仍然发现了一些错误。人类是容易出错的。我们特别不擅长检查事物，因为我们往往倾向于看到我们期望看到的东西，而不是真正存在的东西。这不是对我们懒惰的批评，而是对我们生物学局限性的承认。我们生来就草率下结论，这对处于敌对环境中的野生人类来说是一个非常好的特征。
软件不能容忍错误；校对和代码审查是不够的。我们需要测试它以检查它是否有效。该测试可以采用多种形式，但无论是我们非正式地运行代码并观察发生的情况，还是在调试器中运行它以观察事物如何变化或运行一系列行为驱动开发 (BDD) 场景，这都是只是我们试图获得有关我们更改的反馈。
正如第 5 章所讨论的，反馈需要快速有效才能有价值。
如果那时我们必须对其进行测试，那么现在唯一的问题是，我们应该如何尽可能高效地进行测试？
我们可以决定等到我们认为我们完成了我们的工作，然后一起测试一切。也许我们可以将我们的软件发布到生产环境中，让我们的用户免费为我们测试？这不是最有可能成功的途径！低质量的工作会产生商业成本；这就是为什么在软件开发中采用工程方法很重要的原因。
我们应该在将更改发布到生产环境之前进行某种形式的评估，而不是交叉手指并希望我们的代码有效。我们可以通过几种不同的方式来组织它。
如果我们等到我们认为我们完成了，我们显然没有得到高质量、及时的反馈。我们可能会忘记我们所做的所有细微差别，因此我们的测试会有些粗略。这也将是一件苦差事。
在这一点上，许多组织决定雇用人员为我们做这些琐事。现在我们又回到了原点，成为财富的人质，猜测我们的软件可能会工作，并依靠其他人告诉我们它没有。与在生产中等待听到我们用户的哀号相比，这无疑是向前迈进了一步，但它仍然是一个低质量的结果。
在流程中添加单独的步骤，以单独的人群的形式，不会提高我们可以收集的反馈的速度或质量。这不是对相关人员的批评；所有人都太慢了，他们所做的事情变化太大，而且成本太高，无法与收集我们需要的反馈的自动化方法相媲美。
我们也会太晚收到这些反馈，并且在我们开发它时不知道我们的软件有多好或多坏。这意味着我们将错过宝贵的学习机会，如果反馈更及时，我们本可以从中受益。相反，我们等到我们认为我们完成了，然后从人们那里得到低质量、缓慢的反馈，不管他们多么熟练和勤奋，他们不知道一个没有经过测试的系统的内部工作原理头脑。
我想我们最终可能会对我们的软件质量感到惊喜，但我怀疑我们更有可能对我们留下的愚蠢错误感到震惊。请记住，我们没有做任何事情其他测试，甚至直到现在才运行它。
我相信你可以说我认为这还不够好。
这是一个坏主意，所以在我们走到这一步之前，我们必须在我们的流程中建立某种检查。现在发现用户无法登录并且我们很酷的新功能实际上损坏了磁盘，为时已晚。
所以如果我们必须做一些测试，让我们聪明点。我们如何组织我们的工作，以最大限度地减少我们需要做的工作量并最大限度地提高我们在进行过程中可以获得的洞察力？
在第二部分中，我们谈到了优化学习，那么我们希望学习什么，最有效、最有效的方法是什么？
在我们将要编写一些代码时，有四类相关的学习：

- “我们正在解决正确的问题吗？”
- “我们的解决方案是否如我们所想的那样奏效？”
- “我们的工作质量如何？”
- “我们的工作效率高吗？”

这些当然是需要回答的复杂问题，但从根本上说，这就是我们在开发软件时感兴趣的全部内容。

## 作为工具的可测试性
如果我们要测试我们的软件，那么为了让我们的生活更轻松，我们应该让我们的软件易于测试，这是有道理的。 我已经（在第 11 章）描述了关注点分离和依赖注入如何使我们的代码更具可测试性。 事实上，很难想象可测试的代码不是模块化的，是内聚的，具有良好的关注点分离，并且表现出信息隐藏。 如果它做所有这些事情，那么它不可避免地会被适当地耦合。
让我们看一个简单的例子，看看让我们的代码更可测试的影响。 在这个例子中，除了遵循我希望能够测试某些东西的推理路线之外，我不会做任何事情。 清单 14.1 显示了一个简单的 Car 类。
清单 14.1 简单汽车示例

```java
public class Car {
    private final Engine engine = new PetrolEngine();

    public void start() {
        putIntoPark();
        applyBrakes();
        this.engine.start();
    }

    private void applyBrakes() {
    }

    private void putIntoPark() {
    }
}
```

这个类有一个引擎，一个 PetrolEngine。 当你“启动汽车”时，它会做一些事情。 发动机将汽车停放，应用刹车，并启动发动机。 看起来不错； 很多人会编写看起来像这样的代码。
现在让我们测试一下，如代码清单 14.2 所示。
清单 14.2 测试一辆简单的汽车

```java
@Test
public void shouldStartCarEngine() {
    Car car = new Car();
    car.start();
    // Nothing to assert!!
}
```

很快，我们就遇到了问题。除非我们决定打破我们汽车的封装并公开私有现场引擎，或者提供一些其他讨厌的后门黑客，允许我们的测试读取私有变量（顺便说一下，这两个想法都很糟糕），否则我们可以不测试汽车！这段代码根本无法测试，因为我们看不到“启动汽车”的效果。
这里的问题是我们已经达到了某种终点。我们访问 Car 的最后一点是调用 start 方法。之后，内部运作对我们来说是不可见的。如果我们想测试汽车，我们需要以某种方式允许访问，这不仅仅是测试的特殊情况。我们希望能够看到引擎。
在这种情况下，我们可以通过依赖注入添加一个测量点来解决这个问题。这是一辆更好的汽车的例子；在这个例子中，我们将传递给 BetterCar 一个我们希望它使用的引擎，而不是隐藏引擎。代码清单 14.3 展示了 BetterCar，代码清单 14.4 展示了它的测试。
清单 14.3 BetterCar

```java
public class BetterCar {
    private final Engine engine;

    public BetterCar(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        putIntoPark();
        applyBrakes();
        this.engine.start();
    }

    private void applyBrakes() {
    }

    private void putIntoPark() {
    }
```

代码清单 14.3 注入了一个 Engine。 这个简单的步骤完全改变了与 PetrolEngine 的耦合； 现在我们的类更加抽象，因为它处理的是 Engine 而不是 PetrolEngine。 它改进了关注点和内聚的分离，因为现在 BetterCar 不再对如何创建 PetrolEngine 感兴趣。
在代码清单 14.4 中，我们看到了 BetterCar 的测试。
清单 14.4 测试 BetterCar

```java
@Test
public void shouldStartBetterCarEngine() {
    FakeEngine engine = new FakeEngine();
    BetterCar car = new BetterCar(engine);
    car.start();
    assertTrue(engine.startedSuccessfully());
}
```

这个 BetterCarTest 使用了一个 FakeEngine，如代码清单 14.5 所示。
清单 14.5 帮助测试 BetterCar 的 FakeEngine

```java
public class FakeEngine implements Engine {
    private boolean started = false;

    @Override
    public void start() {
        started = true;
    }

    public boolean startedSuccessfully() {
        return started;
    }
}
```

FakeEngine 除了记录 start 被调用之外什么都不做。1
这个简单的更改使我们的代码可测试，并且如我们所见，变得更好。然而，除了可能看似抽象的质量属性，如模块化和内聚性，最好以更简单、更实用的方式。
因为我们使我们的代码可测试，所以现在更加灵活。使用 PetrolEngine 创建 BetterCar 很简单，但使用 ElectricEngine 或 FakeEngine 甚至 JetEngine 创建 BetterCar 也很简单。我们的 BetterCar 是更好的代码，它是更好的代码，因为我们专注于让它更容易测试。
旨在提高代码可测试性的设计使我们能够设计出更高质量的代码。当然，这不是灵丹妙药。如果你不擅长编码，你的编码可能仍然很糟糕，但如果你努力使它可测试，它会比你通常实现的更好。如果您擅长编码，那么您的代码会更好，因为您使它可测试。

## 测量点

我们示例中的 FakeEngine 展示了另一个重要的想法：测量点。如果我们希望我们的代码可测试，我们需要能够控制变量。我们希望能够准确地注入我们需要的信息，而且只注入这些信息。为了让我们的软件进入可以测试的状态，我们调用了一些行为，然后我们需要结果是可见的和可测量的。

1. 在实际测试中，我们会选择使用 Mocking 库而不是自己编写此代码。我在此处包含了 FakeEngine 代码以使示例清晰。

当我说“可测试性设计”时，这确实是我的意思。我们将设计我们的系统，以便有许多测量点，在这些地方我们可以检查系统的行为而不会影响其完整性。这些测量点将采用不同的形式，具体取决于组件的性质和我们考虑可测试性的级别。
对于细粒度测试，我们将依赖函数或方法的参数和返回值，但我们也会使用依赖注入，如代码清单 14.4 所示。
对于更大规模的系统级测试，我们将伪造外部依赖项，以便我们可以将测量点探针插入系统，允许我们注入测试输入或收集测试输出，如我在第 9 章中所述。

## 实现可测试性的问题
许多团队都在努力实现我在这里描述的那种可测试性，这有两个主要原因。一是技术难点；另一个是更多的文化问题。
正如我们已经探索过的，任何形式的测试都需要我们访问一些合理的测量点。这对于我们的大部分代码来说都很好。使用依赖注入和良好的模块化设计等技术，我们可以组织我们的代码以使其可测试，但这在我们系统的边缘变得困难，在我们的系统以某种方式与现实世界（或至少接近电脑传真）。
如果我们编写的代码写入磁盘，在屏幕上绘制，或者控制或响应某些其他硬件设备，那么系统的边缘很难测试，因为我们如何注入一些测试代码来注入测试数据或收集检测结果？
这个问题的显而易见的答案是设计我们的系统，以便我们代码中的这些“边缘”被推到边缘并最小化它们的复杂性。这实际上是关于减少系统主体与这些边缘的耦合。这反过来又减少了我们对第三方软件元素的依赖，让我们的代码更加灵活，只需要很少的额外工作。
我们创建了一些合适的抽象来代表我们在这个边缘的交互，编写测试来评估我们系统与这个抽象的假版本的交互，然后编写一些简单的代码来将抽象转换为与边缘技术的真实交互。这是一种冗长的说法，即我们添加了一个间接级别。
清单 14.6 显示了一些需要显示某些内容的代码的简单示例。我们可以创建一个带有摄像头的机器人，将输出记录在某种屏幕上，但这有点矫枉过正。相反，我们通过注入一段提供“显示”某些文本能力的代码来抽象显示某些结果的行为。
清单 14.6 要显示的东西

```java
public interface Display
{
    void show(String stringToDisplay);
}

public class MyClassWithStuffToDisplay
{
    private final Display display;

    public MyClassWithStuffToDisplay(Display display)
    {
        this.display = display;
    }

    public void showStuff(String stuff)
    {
        display.show(stuff);
    }
}
```

通过抽象显示信息的行为，我获得了很好的副作用，我的类现在与任何实际的显示设备分离，至少在我提供的抽象范围之外。 显然，这也意味着现在我们可以在没有真正的 Display 的情况下测试这段代码。 我在代码清单 14.7 中包含了这样一个测试的例子。
清单 14.7 测试要显示的东西

```java
@Test
public void shouldDisplayOutput() throws Exception
{
    Display display = mock(Display.class);
    MyClassWithStuffToDisplay displayable = new MyClassWithStuffToDisplay(display);

    displayable.showStuff("My stuff");

    verify(display).show(eq("My stuff"));
}
```

最后，我们可以创建 Display 的具体实现。 在代码清单 14.8 所示的这个简单案例中，它是一个 ConsoleDisplay，但如果需要，我们可以想象用各种不同的选项替换它，例如 LaserDisplayBoard、MindImprintDisplay、3DGameEngineDisplay 等。
清单 14.8 显示内容

```java
public class ConsoleDisplay implements Display
{
    @Override
    public void show(String stringToDisplay)
    {
        System.out.println(stringToDisplay);
    }
}
```

清单 14.5 到 14.8 是微不足道的，如果我们在这个边缘交互的技术更复杂，抽象显然需要更复杂，但原则仍然存在。

> **边缘测试**
>
> 在我参与的一个项目中，我们以这种方式抽象了 Web DOM，以使我们的网页逻辑单元可测试。
> 现在有更好的选择，但当时在没有真正的浏览器的情况下对 Web 应用程序进行单元测试是很棘手的。 我们不想因为必须为每个测试用例启动一个浏览器实例而减慢我们的测试速度，所以我们改变了我们编写 UI 的方式。
> 我们编写了一个“位于 DOM 前面”（用于 DOM 的端口和适配器）的 UI 组件库，因此如果我们需要一个表，我们可以通过我们自己的 DOM 工厂创建一个 JavaScript 表。 在运行时，这为我们提供了一个瘦外观对象，为我们提供了一个可以使用的表。 在测试时，它给了我们一个可以测试的存根，但不需要真实的浏览器或 DOM 的存在。

你总是可以这样做。这实际上只是您尝试抽象的技术的难易程度以及您认为这足以花费努力的重要程度的问题。
对于这些“系统的边缘”，几乎总是值得付出努力的。有时，例如，在 Web UI 或移动应用程序测试中，其他人可能已经为您完成了这项工作，但这是进行边缘单元测试的方法。
这种方法的问题，以及任何真正解决这个问题的方法，都是文化问题。如果我们从一开始就认真对待可测试性并在我们的设计方法中采用它，这一切都非常容易。
当我们编写的代码没有考虑到可测试性，或者人们认为它不重要时，这会变得更加困难。这种文化冲突是一个棘手的问题。
代码可能是问题中更容易处理的部分，尽管更容易并不一定意味着“容易”。我们总是可以添加我们自己的抽象，即使它们是有漏洞的，并使其更易于测试。如果真的必须，我们可以在测试范围内包含不妥协的“边缘”代码。这是一个令人不快的妥协，但在某些情况下是可行的。
困难的问题是人。我并不傲慢地说，从来没有一个团队实践过真正的 TDD，即“在编写代码驱动的开发之前先编写测试”，然后发现它不起作用，但我从来没有遇到了一个。
我遇到过很多团队，他们告诉我“我们尝试过 TDD，但没有奏效”，但是我遇到的所有团队都说他们在尝试编写单元测试后的意思是写了代码。这在很大程度上不是一回事。
不同之处在于 TDD 鼓励可测试代码的设计，而单元测试则不鼓励。单元测试，在代码写好之后，鼓励我们偷工减料，打破封装，并将我们的测试与我们已经编写的代码紧密耦合。
TDD 作为软件开发工程方法的基石是必不可少的。我不知道有任何其他实践可以有效地鼓励和增强我们根据本书中的想法创建优秀设计的能力。
我有时听到的反对 TDD 的最有力论据是，它会损害设计质量并限制我们更改代码的能力，因为测试与代码是耦合的。我从未在使用“测试优先 TDD”创建的代码库中看到过这种情况。不过，作为“测试后单元测试”的结果，这是很常见的——我会说这是不可避免的。所以我怀疑当人们说“TDD 不起作用”时，他们真正的意思是他们还没有真正尝试过 TDD，虽然我确信这可能并非在所有情况下都是如此，但我同样确定它在大多数情况下是正确的，因此是对真理的一个很好的近似。
对设计质量的批评特别贴近我的心，因为我怀疑你可以从这本书中看到，我非常关心设计的质量。
如果我假装我在软件开发、软件设计和 TDD 方面没有一些技能，那我就是虚伪的。我很擅长，我只能猜测原因。我有经验，当然。我可能有一些天赋，但比所有这些更重要的是，我有一些让我远离麻烦的好习惯。 TDD 为我提供了关于我设计质量的更清晰的反馈，因为它的发展比我所知道的任何其他事物都要清晰，并且是我工作和推荐他人工作方式的基石。

## 如何提高可测试性
第二部分描述了优化学习的重要性。我的意思不是从某种宏大的学术意义上说。我的意思是在日常工程的细粒度、实用意义上。所以我们将迭代工作，为我们面前的工作添加一个测试。我们希望从我们的测试中获得快速、高效、清晰的反馈，以便我们可以在很小的时间范围内每隔几分钟快速了解我们的代码正在按照我们的预期执行。
为此，我们希望对系统进行划分，以便我们可以清楚地看到反馈的含义。我们将在小的、单独的代码段上逐步工作，限制我们评估的范围，以便在我们继续进行时清楚发生了什么。
我们可以实验性地工作，将每个测试用例构建为一个小实验，以预测和验证我们想要的代码行为。我们编写了一个测试来捕捉软件应该如何运行的假设。我们在运行之前预测测试将如何失败，以便我们可以验证我们的测试实际上是在测试我们期望的结果。然后，我们可以创建使测试通过的代码，并使用稳定、通过的代码和测试组合作为平台来审查我们的设计，并进行小的、安全的、保护行为的更改，以优化我们的代码和测试的质量。
这种方法让我们深入了解我们的设计，因为它在更深刻的意义上取得进展，而不仅仅是“它是否通过了测试？”如果我们注意，我们代码的可测试性会引导我们朝着更高质量的结果前进。
我们没有足够的工具来为我们做这种事情，我们忽略这个工具会带来危险。太多的开发人员和开发团队忽略了这一点，并以比他们能够和应该的速度更慢的速度生产更糟糕的软件。
如果您之前的测试难以编写，则您正在使用的代码的设计很差，需要改进。
我们系统的可测试性是分形的。我们可以在整个企业系统级别和几行代码的狭窄焦点上观察它并将其用作工具，但它是我们工具箱中最强大的工具之一。
在函数和类的细粒度级别，可测试性最重要的方面是测量点。它们定义了我们在特定状态下建立代码的难易程度以及我们观察和评估其行为结果的难易程度。
在更系统和多系统的层面上，重点更多地放在评估和测试的范围上。测量点的基础仍然很重要，但评估范围是一个重要的工具。

## 可部署性
在我的《持续交付》一书中，我们描述了一种基于工作理念的开发方法，以便我们的软件始终处于可发布状态。在每次小的更改之后，我们都会评估我们的软件以确定其可发布性，并且我们每天都会多次获得该反馈。
为了实现这一点，我们采用了一种称为部署管道的机制。部署管道旨在通过高度自动化来尽可能确定可发布性。
那么“可释放”是什么意思呢？不可避免地，这有点上下文。
我们当然需要知道代码做了开发人员认为它做的事情，然后知道它做了用户需要它做的事情会很好。之后，我们想知道该软件是否足够快、足够安全、足够有弹性，并且是否符合任何适用的法规。
这些都是部署管道的任务。到目前为止，我已经从可发布性的角度描述了部署管道，但在我们继续之前，我想摆脱一些细微的差别。
实际上，在描述部署管道时，我区分了可发布和可部署。这是一个微妙的观点，但从开发的角度来看，我想将“准备将更改部署到生产中”与“向用户发布功能”分开。
在持续交付中，我们希望能够在一系列部署中自由地创建新功能。所以在这一点上，我要从可发布性（意味着一些功能完整性和对用户的实用性）转向可部署性，这意味着软件可以安全地发布到生产环境中，即使某些功能尚未准备好使用和以某种方式隐藏。
因此，我们系统的可部署性由许多不同的属性组成；软件单元必须能够部署，并且必须满足在该系统上下文中有意义的所有可发布性属性：足够快、足够安全、足够有弹性、可以工作等等。
这种可部署性的想法在系统和架构级别是一个非常有用的工具。如果部署管道表明系统可部署，则它已准备好部署到生产中。
很多人误解了持续交付，但这就是部署管道的用途。如果部署管道表明变更是好的，那么在我们将变更部署到生产环境之前，就不需要再进行测试，没有更多的签核，也不需要与系统其他部分的进一步集成测试。我们不必部署到生产环境中，但如果更改已被管道批准，则准备就绪，如果我们愿意的话。
这门学科说明了一些重要的事情。它将可部署性定义为“没有更多的工作要做”，这意味着要实现可部署的结果，我们必须在可部署单元级别认真对待模块化、内聚、关注点分离、耦合和信息隐藏的思想。软件。
我们的评估范围应该始终是一个可独立部署的软件单元。如果我们不能在没有进一步工作的情况下自信地将更改发布到生产中，那么我们的评估单元，即部署管道的范围，就是不正确的。
有多种方法可以解决这个问题。我们可以选择将系统中的所有内容都包含在评估范围内、部署管道的范围内，或者我们可以选择将系统分解为可独立部署的软件单元，但没有其他任何意义。
我们可以将系统的多个组件组织到不同的地方，从不同的存储库中构建，但评估范围是由可部署性需求驱动的。所以如果我们选择这条路，觉得有必要在发布前一起评估这些组件，那么评估的范围，部署管道的范围，仍然是整个系统。这很重要，因为无论系统的一小部分评估有多快，评估变更的可部署性所花费的时间才是真正重要的。所以这应该是我们优化目标的范围。
这意味着可部署性是创建系统的一个重要问题。用这些术语思考意味着它有助于我们将注意力集中在我们必须解决的问题上。我们如何在合理的时间范围内获得反馈以指导我们的开发工作？

## 速度
这让我们加速。正如我们在第二部分中所讨论的，我们在开发过程中获得的反馈的速度和质量对于我们优化学习至关重要。在第 3 章中，我们讨论了测量的重要性，并重点讨论了稳定性和吞吐量的使用。作为衡量我们开发过程效率的指标，吞吐量显然与速度有关。
当我咨询团队以帮助他们采用持续交付时，我建议他们专注于工作以减少获得反馈所需的时间。
我通常会提供一些指导方针：我告诉他们努力优化他们的开发过程，这样他们就可以获得可发布的结果，一个生产质量的可部署软件单元，每天多次，强烈偏好更短的时间。作为一个目标，我通常建议将目标设为可以在任何更改提交后不到一小时内部署到生产中的东西。
这可能是一个具有挑战性的目标，但只要考虑一下这样的目标意味着什么。你不能拥有太大的团队，因为沟通开销会大大减慢他们的速度。你不能有孤立的团队，因为团队之间的协调成本会太慢。你必须在自动化测试方面有很好的地位，你需要像持续集成和持续交付这样的反馈机制，你必须有良好的架构来支持这些类型的策略，你需要评估可独立部署的软件单元等等在不到一小时的时间内获得可发布的结果。
如果您采用迭代的、实验性的方法来仅提高开发过程中的反馈速度，那么它就充当了所有敏捷理论、所有精益理论以及所有持续交付和 DevOps 的一种适应度函数。
这种对速度和反馈的关注会导致你无情地想到这些想法。与遵循一些现成的开发过程中的一些仪式或食谱相比，这是一个更强大、更可衡量的指南，可以帮助您获得更好的结果。这就是我在谈论软件工程时的意思。
速度是一种工具，我们可以使用它来指导我们获得更高质量、更有效的结果。

## 控制变量
如果我们希望能够快速、可靠和可重复地测试和部署我们的系统，我们需要限制方差，我们需要控制变量。我们每次部署软件时都希望获得相同的结果，因此我们需要尽可能自动化部署并管理我们部署的系统的配置。
在我们无法控制的地方，那么我们必须非常小心地对待那些触及不受控制的世界的系统边缘。如果我们将软件部署到我们无法控制的环境中，我们希望尽可能地依赖它。抽象、关注点分离和松散耦合是限制我们暴露于我们直接控制之外的任何事物的关键思想。
我们希望我们创建的测试在每次为相同版本的被测软件运行时都能给出完全相同的结果。如果测试结果不同，那么我们应该努力施加更大的控制，以更好地将测试与外部影响隔离或改进我们代码中的确定性。模块化和内聚、关注点分离、抽象和耦合再次是允许我们施加这种控制的关键思想。
如果存在需要进行长时间运行的测试或手动测试的诱惑，这些通常是不适当缺乏控制变量的症状。
我们通常没有足够认真地对待这个想法。

> **控制不力的成本**
>
> 我曾经为一个构建大型复杂分布式软件系统的大型组织提供咨询。 他们有 100 多个开发人员团队致力于该项目。 他们让我就性能测试向他们提出建议。
> 他们为整个系统创建了一个大型复杂的端到端性能测试套件。
> 他们曾四次尝试运行他们的性能测试套件，但现在他们不知道结果意味着什么。
> 结果如此多变，以至于无法在测试运行之间进行比较。
> 造成这种情况的原因之一是他们在公司网络上运行了测试，因此根据当时发生的其他情况，结果完全有偏差。
> 创建和执行这些测试的所有工作基本上都是浪费，因为没有人能说出结果的含义。

计算机给了我们绝佳的机会。忽略宇宙射线和中微子与我们的 NAND 门（两者都由硬件纠错协议提供）的碰撞，计算机和在它们上运行的软件是确定性的。给定相同的输入，计算机每次都会生成相同的输出。这个事实的唯一限制是并发。
计算机的速度也非常快，为我们提供了一个前所未有的梦幻般的实验平台。我们可以选择放弃这些优势，或者控制并利用它们为我们带来优势。
我们如何设计和测试我们的系统对我们可以施加的控制程度有很大影响。这是从测试驱动我们的设计的另一个优势。
可靠的可测试代码在测试范围内不是多线程的，除了一些非常特殊的测试类型。
并发代码很难测试，因为它不是确定性的。因此，如果我们将代码设计为可测试的，我们将仔细考虑并发性并努力将其移动到我们系统的受控、易于理解的边缘。
根据我的经验，这导致代码更容易测试，因为它是确定性的，而且代码更容易理解，当然在我工作的地方，代码在计算上更高效。

## 持续交付

持续交付是一种组织理念，可帮助我们将这些想法整合为有效、高效、可行的开发方法。使我们的软件始终可发布的工作将我们的注意力集中在部署管道中的评估范围和我们软件的可部署性上。这为我们提供了一些工具，我们可以使用这些工具来构建我们的代码和我们的组织，以创建这些可独立部署的软件单元。
持续交付与自动化部署无关，尽管这是其中的一部分；这是关于组织我们的工作的更重要的想法，以便我们创建半连续的变化流。
如果我们认真对待这个想法，那么它要求我们构建我们开发方法的所有方面来实现这个流程。它对我们组织的结构产生影响，最大限度地减少组织依赖性并促进小团队的自治，这些团队可以快速、高质量地工作，而无需与其他人协调工作。
它要求我们应用高度自动化，尤其是在测试我们的软件时，以便我们能够快速有效地了解我们的更改是安全的。因此，它鼓励我们非常认真地对待这种测试，因此我们最终得到了可测试的软件，并可以从它带来的所有优势中受益。
持续交付指导我们测试系统的部署和配置，并迫使我们认真对待控制变量的想法，以便我们能够在测试中实现可重复性和可靠性，作为副作用，在我们的生产部署中。
持续交付是一种非常有效的策略，围绕它为软件开发建立强大的工程学科。

## 支持工程的通用工具
这些是通用工具。这些想法适用于软件中的任何问题。
我们来看一个简单的例子。想象一下，我们想要向我们的系统添加一些软件——第三方组件、子系统或框架。我们如何评价它？
当然，它必须起作用并为我们的系统提供某种价值，但在此之前，我相信您可以使用本章和本书其余部分中的想法作为限定词。
技术可以部署吗？我们能否自动部署系统，以便我们可以可靠且可重复地部署它？
是否可测试？我们可以确认它正在做我们需要它做的事情吗？详尽地测试第三方软件不是我们的工作；如果我们必须这样做，它可能不够好，不够高质量，供我们使用。但是，在某种程度上，我们想要测试它是否在我们的系统上下文中执行所需的操作，它是否配置正确，是否在我们需要时启动并运行，等等？我们可以测试一下吗？
它允许我们控制变量吗？我们能否可靠且可重复地部署它？我们可以对部署和任何配置进行版本控制吗？
在持续交付环境中工作是否足够快？我们能否在合理的时间内部署它并足够快地启动和运行，以便能够每天多次使用和评估它？
如果它是一个我们将编写与之接口的代码的软件组件，它是否允许我们维护代码设计的模块化方法，或者它是否强制我们使用自己的编程模型，从而在某些方面损害我们的设计？道路？
对这些问题中的任何一个的错误答案几乎肯定会使我们失去这项技术的资格，然后我们甚至还要看看它是否做得很好并且在其他情况下是否有用。
除非该第三方技术提供的服务必不可少，否则我建议我们寻求替代方案。如果该服务是必不可少的，那么尽管有技术，我们仍需要努力实现这些特性。这是一项需要考虑到这项技术的成本效益计算的成本。
这个小例子旨在为这种思维方式的普遍性提供一个模型。我们可以使用学习工具、管理复杂性的工具，以及这些工具来支持工程方法，为我们工作的各个方面的决策和选择提供信息。

## 概括

本章将我在本书中提出的相互关联的想法汇集到一个连贯的模型中，以便更有效地开发软件。通过采用本章中的思想作为我们处理软件开发方式的组织原则，我们将获得比忽略它们更好的结果。
这是我们对任何工具、过程或学科所能期望的最好的结果。没有成功的保证，但是通过应用我在此处和本书中描述的思想，我相信您将更快地创建更高质量的代码。